# 1. 概述

本章概述了 TON 区块链的主要特征和设计原理。后续章节提供了有关每个主题的更多详细信息。

## 1.1 一切都是单元

区块中的所有数据和 TON 区块链的状态表示为单元的集合（参见[3, 2.5]）。因此，本章首先对单元进行一般性讨论。

### 1.1.1 TVM 单元

 回想一下，TON 区块链以及 TON 虚拟机（TVM; 参见[4]）将所有永久存储的数据表示为所谓的单元的集合或"包"(bag of cells)。 每个单元由最多 1023 个数据位和最多四个对其他单元的引用组成。 不允许单元循环引用，因此单元通常被组织成单元树，或者更确切地说是单元的有向无环图（DAG）。任何抽象的代数（依赖）数据类型都可以表示（序列化）为单元树。 将抽象数据类型的值通过 TL-B Schemes 精确的表示为单元树。在 [4, 3.1] 中可以找到对不同类型单元的更全面的讨论。


### 1.1.2 单元应用于 TON 区块和状态

单元特别适用于 TON 区块链的块和状态，它们也是某些（非常复杂的）从属代数数据类型的值。因此，它们根据各种 TL-B Schemes（在本文件中逐渐呈现）进行序列化，并表示为单元的集合或包。

### 1.1.3 单个单元的布局

每个单个单元由最多 1023 个数据位和最多四个对其他单元的引用组成。 当单元保存在内存中时，其精确表示与实现有关。然而，存在单元的标准表示，例如，用于序列化文件存储或网络传输的单元。单元 *c* 的“标准表示”或“标准布局”(CellRepr(c))由以下组成：

1. 首先是两个描述符字节，有时用 *d<sub>1</sub>* 和 *d<sub>2</sub>* 表示。 第一个字节 *d<sub>1</sub>* 等于（在最简单的情况下）单元的引用数量 *0 ≤ r ≤ 4*。 第二个描述符字节 *d<sub>2</sub>* 对单元数据部分的比特长度 *l* 进行编码，如下所示： *d<sub>2</sub>* 的前 7 位等于 ⌊l/8⌋ 即单元中存在的完整数据字节的数量，而 *d<sub>2</sub>* 的最后一位是*完成标记*(*completion tag*)，如果 l 不能被 8 整除，则等于1。 因此，

> (式1) d<sub>2</sub> = 2⌊l/8⌋ + [l mod 8̸ ≠ 0] = ⌊l/8⌋ + ⌈l/8⌉

> 当条件 A 为真时，[A] 等于 1，否则为零。

2. 接下来是 ⌈l/8⌉ 个数据字节。这意味着单元的 l 个数据位被分成 8 个组，每个组被解释为大端 8 位整数并存储到一个字节中。如果 l 不能被 8 整除，则将单个二进制 1 和适当数量的二进制 0（最多 6 个）附加到数据位，并设置完成标记（描述符字节 d<sub>2</sub> 的最低有效位）。

3. 最后是 *r* 个对其他单元的引用。每个引用通常由 32 个字节表示，其中包含引用单元的 SHA256 哈希值，计算方法如 1.1.4 中所述。

以这种方式，具有 *l* 个数据位和 *r* 个引用的单元 *c* 的标准表示 CellRepr(c) 是 *2 + ⌊l/8⌋ + ⌈l/8⌉ + 32r* 字节长。

### 1.1.4 单元的 SHA256 哈希值

单元 *c* 的 SHA256 散列被递归定义为所讨论单元的标准表示 CellRepr(c) 的 SHA256：

> (式2) Hash(c) := SHA256(c) := SHA256(CellRepr(c))

由于不允许单元循环引用（所有单元之间的关系必须构成有向无环图或 DAG），因此单元的 SHA256 散列始终是明确定义的。

此外，因为 SHA256 默认抗碰撞，所以我们假设所有单元完全由它们的哈希决定。 特别地，单元 *c* 的单元引用完全由引用单元的散列确定，其包含在标准表示 CellRepr(c) 中。

### 1.1.5 外来单元

除了到目前为止的普通单元（也称为简单单元或数据单元）之外，其他类型的单元（称为外来单元）有时也出现在 TON 区块和其他数据结构的实际表示中。 他们所代表的事物有所不同，通过使第一个描述符字节 d<sub>1</sub> ≥ 5来区分它们（参见 [4, 3.1]）。

### 1.1.6 外部引用单元

（外部）引用单元是外来单元的一个示例，其包含“真实”数据单元 *c* 的 32 字节 SHA256(c)。这些单元可以用于对应于 TON 区块的一个单元集合的序列化，以便指代在块本身的序列化中不存在的数据单元，而是假设存在于其它地方（例如，在区块链之前的状态中）。

### 1.1.7 引用单元的透明度与大多数操作有关

大多数单元操作都不会关心任何引用单元或其它“外来”单元; 他们只知道数据单元，任何引用单元都会被所引用到的单元替代。 例如，当递归地计算透明单元散列 Hash<sup>♭</sup>(c) 时，是将引用单元的散列设置为等于所引用的单元的散列，而不是引用单元的标准表示的散列。

### 1.1.8 透明哈希和单元的表示哈希

这样，SHA256<sup>♭</sup>(c) = Hash<sup>♭</sup>(c) 是单元 *c*（或以 *c* 为根的单元树）的透明哈希。

但是，有时我们需要推断块中单元树的精确表示。为此，定义了*表示哈希(representation hash)* Hash<sup>♯</sup>(c)，其对于引用单元和其它外来类型的单元是不透明的。 我们经常说 *c* 的*表示哈希*是 *c* 的“哈希”，因为它是单元中最常用的哈希。

### 1.1.9 使用表示哈希用于签名

签名是表示哈希应用的一个很好的例子。 例如：

1. 验证人签署块的表示哈希，而不仅仅是它的透明哈希，因为它们需要证明块确实包含所需的数据，而不仅仅是对它们的一些外部引用。

2. 当外部消息由链下（例如，使用应用程序启动区块链交易的人类客户端）签名和发送时，如果其中一些消息可能存在外部引用，则必须签名消息的表示哈希值。

### 1.1.10 高阶哈希

除了单元 *c* 的透明和表示哈希之外，还有一系列*高阶哈希(Higher hashes)* Hash<sub>i</sub>(c), i = 1, 2, ...。 可能最终稳定在 Hash<sub>∞</sub>(c)。 （更多细节可以在[4, 3.1]中找到。）

## 1.2 块的主要组件和区块链状态

本节简要介绍了块的主要组件和区块链状态，而没有深入研究细节。

### 1.2.1 无限分片范式（ISP）适用于区块和区块链状态。

回想一下，根据无限分片范式，每个帐户可以被视为位于其单独的“帐户链”中，然后这些帐户链的（虚拟）块被分组为分片块以提高效率。 粗略地讲，分片链的状态大致包括所有“帐户链”的状态（即分配给它的所有帐户）; 类似地，分片的一个块基本上由分配给该分片的一些帐户的虚拟“块”集合组成。

我们可以总结如下:

> (式3) ShardState ≈ Hashmap(n, AccountState)
> (式4) ShardBlock ≈ Hashmap(n, AccountBlock)

其中 n 是 account_id 的位长，Hashmap(n, X) 描述了从长度为 n 的位串到 X 类型值的部分映射 2<sup>n</sup> ---> X。

回想一下，每个分片块对应于属于相同“工作链”的所有帐户链（即，具有相同的 workchain_id = w）并且具有以相同的二进制前缀 *s* 开头的 account_id，以便 *(w, s)* 完全确定一个分片。因此，上述哈希映射必须仅包含以前缀 *s* 开头的键。

我们稍后会看到上面的描述只是一个近似值：分片的状态和块需要包含一些额外的数据，这些数据不是根据（式3）建议的 account_id 分割的。

### 1.2.2