# 2. TON Blockchain

我们将从叙述 TON 的核心组件 —— TON Blockchain 开始。叙述的方法是“自上而下”：我们首先给出整体的一般描述，然后提供每个组件的更多细节。

尽管原则上该区块链协议的若干个实例可以独立运行（例如，由于硬叉），为简单起见，我们在这里谈论 TON 区块链时只考虑其中一个。

## 2.1 TON Blockchain 是二维区块链

TON Blockchain 是区块链的集合（甚至是区块链集合的集合），因为没有一个单链区块链项目有能力满足百万级TPS的目标，而不是现在标准的每秒数十个交易。

### 2.1.1 区块链类型

该区块链是以下区块链的集合:

1. 主链(Masterchain): 包含协议和当前参数值的一般信息，认证人及其股权信息，工作链(Workchains)以及分片信息，以及最重要的最近工作链和分片链(Shardchains)的区块 Hash 集合。

2. 工作链(Working blockchains, Workchains): 作为“主力”的工作链最多有 2^32 个，它们包含了交易和只能合约。不同的工作链可能有不同的“规则”，这意味着它们拥有不同的账号地址格式、不同的交易格式、不同的智能合约虚拟机、不同的基础货币等等。然而，它们必须满足某些基本的互操作性标准，才能是不同的工作链之间的交互成为可能并且相对简单。在这方面，TON 区块链是异质(heterogeneous)的，类似于 EOS 和 PolkaDot 项目。

3. 分片链(Shardchains): 每一条工作链最多可以分成 2^60 个分片链。它们具有和工作链相同的规则和区块格式，但本身只负责一个账户子集。换句话说，系统中内置了一种分片形式。 因为所有这些分片链共享一个共同的块格式和规则，所以 TON 区块链在这方面是同质(homogeneous)的，类似于以太坊扩展提议中讨论的内容。

4. 在分片链中的每一个区块事实上并不是区块，而是一条链。通常块区块链或纵向区块链的区块里只包含一个块，然后我们会认为这对应分片链中的一个区块（这种情况下我们称之为“横向区块链”）。但是，如果需要修复不正确的分片链，则需要向纵向区块链中提交一个新的区块，这其中包含无效的横向区块链的块的替换，或者仅包含需要更改此块的先前版本的那些部分的描述。这是一种用于替换检测到的无效块的 TON 特定机制，而不会让分片链分叉，2.1.17将会对此有详细描述。现在，我们仅仅认为每个分片链不是传统的区块链，而将其认为是区块链的区块链或二维区块链。

### 2.1.2 无限分片范式

几乎全部的区块链的分片提议都是“自上而下”的: 首先想象有一条链，然后讨论如何将其拆分成几个交互的分片链，以提高性能并实现可扩展性。

TON 的分片方法是“自下而上”的，解释如下。

想象一下，将分片发挥到极致，那么每一条分片链中只保留一个账户或智能合约。这样我们就会有大量的“账户链”，每个账户链描述一个账户的状态和状态转换，并相互发送消息以传输价值和信息。

当然，拥有数亿条区块链是不切实际的，其中每个区块链通常很少出现更新（即新区块）。 为了更有效地实现它们，我们将这些“帐户链”分组为“分片链”，以便分片链的每个块本质上是已分配给此分片的帐户链块的集合。 因此，“帐户链”在“分片链”中仅具有纯粹的虚拟或逻辑存在。

我们将这种观点称为**无限分片范式**，它解释了 TON 区块链的许多设计决策。

### 2.1.3 消息、即时超立方路由

无限分片范式告诉我们将每个帐户（或智能合约）视为自己的分片链。 那么一个帐户可能影响另一个帐户状态的唯一方法就是向它发送一条消息（这是所谓的 Actor 模型的特殊实例，帐户为 Actors）。 因此，一个不同账户之间的消息系统（因为源账户和目标帐户通常位于不同的分片链中）对于可扩展系统（如TON区块链）至关重要。 实际上，TON 区块链的一个新功能，称为即时超立方路由，使其能够将在一个分片块中创建的消息传递和处理到目标分片链的下一个块中，而不管系统中分片链的总数。

### 2.1.4 主链、工作链与分片链的数量

TON 区块链只包含一个主链。 但是，该系统最多可以容纳 2^32 个工作链，每个工作链最多可分为 2^60 个分片链。

### 2.1.5 工作链通常是虚拟的链，而不是真实的链

因为工作链通常被细分为分片链，所以工作链的存在是“虚拟的”，这意味着它不是真正的链，而是在下面2.2.1中描述的一般定义——只是一组分片链。 当只有一个分片链对应一个工作链时，这个独特的分片链可以认为是工作链，在这种情况下，工作链至少在一段时间内成为“真正的”区块链，从而获得与传统的单区块链设计的表面相似性。 然而，无限分片范式告诉我们，这种相似性确实是肤浅的: 潜在的大量“账户链”可以暂时归为一条区块链（分片链）仅仅只是一个巧合。

### 2.1.6 工作链的ID

每个工作链由其编号或由一个无符号的32位整数（workchain_id：uint32）标识。 工作链由主链中的特殊交易创建，该交易用于定义（以前未使用的）工作链标识符和工作链的正式描述，以使该工作链与其他工作链可交互以及可对该工作链的块进行验证。

### 2.1.7 工作链的创建与激活

只需准备好支付发布新工作链规范所需的（高）主链交易费用，基本上任何社区成员都可以创建新的工作链。 但是，为了激活新的工作链，需要三分之二的验证人共识，因为他们需要升级他们的软件来处理新工作链的块，并表示它们已经准备好通过特殊的主链交易使新的工作链生效。 对激活新工作链感兴趣的一方可能会通过智能合约分发的一些奖励来为验证人提供一些激励，以便支持新的工作链。

### 2.1.8 分片链的ID

每条分片链由一对元组 (w, s) = (workchain_id，shard_prefix) 标识，其中 workchain_id: uint32 标识相应的工作链，shard_prefix: 2^(0...60) 是一个长度最多为 60 的位串，定义了这个分片链负责的帐户子集。 即所有具有以 shard_prefix 开头的 account_id 的帐户（也就是说将 shard_prefix 作为最高有效位）将被分配给该分片链。

### 2.1.9 账户链的ID

回想一下，帐户链只是虚拟的存在。 但是，它们有一个自然的标识符 - 即 (workchain_id，account_id) - 因为任何帐户链都包含有关状态的信息和正好一个帐户（简单帐户或智能合约）的更新。

### 2.1.10 分片链的动态拆分与合并

一个不太复杂的系统可能使用静态分片。例如，通过使用 account_id 的前八位来选择 256 个预定义分片中的一个。

TON 区块链的一个重要特征是它实现了动态分片，这意味着分片数量是不固定的。相反，如果满足某些条件，则分片 (w，s) 可以自动细分为分片 (w，s.0) 和 (w，s.1)（比如很长一段时间内，原始分片上的交易负载足够高）。 相反，如果负载在一段时间内保持过低，则分片 (w，s.0) 和 (w，s.1) 可以自动合并回 shard (w，s) 。

因此，最初只为 工作链w 创建了一个分片 (w，∅)。 之后如果有必要，它会细分为更多的分片（参见2.7.6和2.7.8）。

### 2.1.11 基本工作链 (Basic Workchain/Workchain Zero)

虽然可以使用特定的规则和交易定义多达 2^32 个工作链，但我们最初只定义了一个工作链，其 workchain_id = 0。此工作链称为 Workchain Zero 或基本工作链，它用于处理 TON 智能合约和转移 TON 代币（也称为 **Gram**，参见附录A）。大多数应用程序可能只需要 Workchain Zero。 基本工作链的分片链将被称为 Basic Shardchains。

### 2.1.12 块生成时间

我们期望在每个分片链和主链中大约每五秒生成一个新块。 这是相当小的交易确认时间。 所有分片链的新块几乎同时生成，并且大约在分片链的新快生成一秒后又生成一个新的主链块，这是因为主链必须包含所有分片链的最新块的哈希值。

### 2.1.13 主链使工作链与分片链紧耦合

一旦分片块的 Hash 被合并到主链的块中，那么该分片块及其所有父块就被认为是“规范的”，这意味着它们可以被所有分片链的后续块中引用为固定不变的东西。 实际上，每个新的分片块也包含最新主链块的 Hash，并且从该主链块引用的所有分片块被更新的块视为不可变的。

本质上，这意味着在分片块中提交的交易或消息可以安全地用在其它分片链的下一个块中，而不需要等待。（举个反例: 在大多数的“松散耦合”系统中，用户在转发消息或发送交易之前需要 20 个确认，例如EOS。）而 TON 这种在提交后仅仅五秒就能使用其它分片链中的交易和消息的能力就是我们认为的“紧密耦合”系统（这是同类产品中的第一个），这也是我们能够提供前所未有的性能的原因之一（参见2.8。 12和2.8.14）。

### 2.1.14 主链的块 Hash 也是全局状态

根据2.1.13，从外部观察者的角度来看，最后一个主链块的 Hash 就完全确定了系统的整体状态，所以不需要分别监视所有分片链的状态。

### 2.1.15 通过认证者生成新块

TON 区块链使用 Proof-of-Stake(PoS) 在分片链和主链中生成新块。 这意味着有一组特殊节点通过特殊的主链交易存入股权（大量 TON 代币），以便有资格进行新的块生成和验证。

然后，以确定性伪随机方式将较小的验证人子集分配给每个分片 (w，s)，并且大约每 1024 个块改变一次。 这个验证人子集通过从客户端收集合适的交易到新的有效候选块，并就下一个块的内容达成共识。 对于每个块，在验证人上存在伪随机选择的顺序，以确定哪个候选块具有最高的优先级。

验证人和其它节点检查候选块的有效性; 如果验证人签署了无效候选块，则可能会因此被惩罚一部分或全部的股权，或者在一段时间内不能验证区块的有效性。 在此之后，其它验证人应该对下一个区块的选择达成共识（主要是通过BFT（拜占庭容错;参见2.8.4）共识协议的有效变体，类似于 PBFT [4]或 Honey Badger BFT[11]）。 如果达成共识，则创建新块，并且验证人在它们之间划分交易费，以及一些系统奖励的代币。

每个验证人能够参与进多个不同验证人子集中。在这种情况下，全部的验证与共识都是并行计算的。

在所有的分片链的新块生成之后，或者生成区块超时，主链就会生成新的一个包括所有分片链的最新块哈希值的块。这是由所有验证人的 BFT 共识完成的。

有关 TON PoS 及其经济模型的更多详细信息，请参见第2.6节。

### 2.1.16 主链的分叉

由紧耦合引起的复杂性是，在主链切换到不同的分支几乎必然需要在至少一些分片链中切换到另一个分支。 另一方面，只要主链中没有分叉，就不可能在分片链中分叉。

一般规则是，如果主链中的块 B' 是 B 的前身，B' 包含分片链(w, s) 的块 B'<sub>w, s</sub> 的 HASH(B'<sub>w,s</sub>)，并且 B 包含了 HASH(B<sub>w, s</sub>)，那么 B'<sub>w, s</sub> 一定是 B<sub>w, s</sub> 的前身，否则主链块中的 B 是无效的。

我们预计主链轮叉是罕见的，甚至是不存在的。因为在 TON 区块链采用的 BFT 范例中，只有在大多数验人行为不正确（这将意味着违法者将遭受重大的股权损失）的情况下才能发生这种情况（参见2.6.1和2.6.15）。 因此，预计分片链中也没有真正的分叉。 相反，如果检测到无效的分片块，它将通过二维区块链的“纵向区块链”机制（参见2.1.17）进行纠正，而不会分叉“横向区块链”（即分片链）。 同样的机制也可用于修复主链块中的非致命错误。

### 2.1.17 更正无效的分片块

通常，在分片链中必须达到三分之二验证人达成拜占庭共识才能提交新块。 但是，系统必须检测先前提交的无效块以及对其更正。

当然，一旦由由验证人或“渔夫(Fishermen)”（系统的任何节点进行了某种存款，而提出有关区块有效性的问题）找到无效的分片块，签署无效区块的验证人将因此失去部分股权和/或被禁职（后一种措施对于攻击者窃取其他良性验证人的签名密钥的情况很重要）。

但这还不够，因为系统的整体状态由于先前提交的分片块无效而证明是无效的。必须使用较新的有效版本替换此无效块。

大多数系统都会通过“回滚”到此分片链中的无效块之前的最后一个块并且该块不受从其他每个分片链中传播无效块的消息的影响，并从这些块创建新的分叉来实现此目的。 这种方法的缺点是大量的其他正确的和提交的交易突然回滚，并且不清楚它们是否稍后还能被有效确认。

TON 区块链通过使每个分片链和主链（横向区块链）的每个“块”自身成为一个小区块链（纵向区块链）来解决这个问题，这个纵向区块链包含不同版本的“块”或它们的“差异”。 通常，纵向区块链只包含一个区块，而分片链则看起来像一个经典的区块链。 然而，一旦确认块的无效性并在主链块中得到确认，则在纵向上允许在该无效块被新块替换以纠正该无效块。 新块由相关分片链的当前验证人子集生成。

新“纵向”块的有效规则非常严格。特别是，如果无效块中包含有效的虚拟“帐户链块”（参见2.1.2），则必须由新的块更正且保持账户链不变。

一旦在无效块之上提交了新的“纵向”块，其哈希就会发布在新的主链块中（或者更确切地说是在新的“纵向”块中，位于包含最初发布的无效分片块HASH的主链块上方），并且引用了该无效快的所有分片快都会更正。这是通过在纵向区块链中为以前引用“不正确”区块的所有区块提交新的“纵向”区块来解决的; 新的纵向块将引用最新（已更正）的版本。 同样，也禁止更改未受影响的帐户链（即，接收与先前版本相同的消息）。 通过这种方式，修复不正确的块会产生“涟漪”，最终传播到所有受影响的分片链的最新块; 这些变化也反映在新的“纵向”主链块中。

一旦该“涟漪”到达最新的块，新的分片块就作为最新块版本的后继者生成。这意味着它们将从一开始就包含对正确纵向块的引用。

主链状态隐含地定义了将每个“纵向”区块链的第一个块的 HASH 转换为其最新版本的 HASH 的映射。 这使客户端能够通过其第一个（通常是唯一的）块的 HASH 来识别和定位任何纵向区块链。

### 2.1.18 TON 代币与多币工作链

TON 区块链支持多达 2^32 种不同的“加密货币”，由 32 位 currency_id 区分。可通过主链中的特殊交易添加新的加密货币。 每个工作链都有一个基本的加密货币，并且可以有多个额外币种。

有一种特殊的加密货币，currency_id = 0，即 TON 币，也称为 **Gram**（参见附录A）。 它是Workchain Zero 的基本加密货币。它也用于充当手续费和验证人的权益收入。

原则上，其他工作链可能会收取其它代币的交易费用。在这种情况下，应提供一些智能合约，将这些交易费自动转换为 Grams。

### 2.1.19 消息与价值转移

属于相同或不同工作链的分片链可以相互发送消息。 虽然消息的确切形式取决于接收工作链和接收帐户（智能合约），但有一些共同的字段使得工作链之间的消息传递成为可能。 特别地，只要它们被接收工作链声明为可接受的加密货币，那么每个消息可以以一定量的 Gram 和/或其他注册的加密货币的形式附带一些价值。

消息传递的最简单形式是从一个（通常不是智能合约）账户到另一个账户的价值转移。

### 2.1.20 TON 虚拟机

TON虚拟机（也称为 TON VM或 TVM）是用于在主链和基本工作链中执行智能合约代码的虚拟机。 其它工作链可以与 TVM 一起使用别的 TVM。

在这里，我们列出了它的一些功能。 它们将在 2.3.12, 2.3.14 和其它地方进一步讨论。

1. TVM 将所有数据表示为 TVM 单元(cell)的集合（参见2.3.14）。每个单元最多包含 128 个数据字节，4 个对其它单元的引用。 由于“一切都是单元”的理念（参见2.5.14），这使 TVM 能够处理与 TON 区块链相关的所有数据，包括块和区块链全局状态（如有必要）。

2. TVM 可以处理任意代数数据类型的值（2.3.12），其表示为 TVM 单元的树或有向无环图。但是，它并不关心数据类型; 数据类型只适用于单元。

3. TVM 内置了对哈希表(Hashmaps)的支持。

4. TVM 是基于栈的虚拟机。 它的堆栈保持64位整数或单元格引用。

5. 支持 64 位，128 位和 256 位算术。 所有 n 位算术运算有三种形式：无符号整数，有符号整数和 2^n 整数模（后一种情况下不进行自动溢出检查）。

6. TVM 具有从 n 位到 m 位的无符号和有符号整数转换，对于所有 0 ≤ m，n ≤ 256，具有溢出检查。

7. 默认情况下，所有算术运算都执行溢出检查，大大简化了智能合约的开发。

8. TVM 具有 "multiply-then-shift" 和 “shift-then-divide” 算术运算，其中间值以大整数类型计算; 这简化了算术的过程。

9. TVM 支持位串和字符串。

10. 支持预定义的 256 位椭圆曲线加密（ECC），包括Curve25519。

11. 还存在对一些椭圆曲线上的 Weil Pairings 的支持，这对于快速实现zk-SNARK是有用的。

12. 支持流行的哈希函数，包括 SHA256。

13. TVM 支持 Merkle Proofs（参见5.1.9）。

14. TVM 支持“大型”智能合约或“全局”智能合约，而这种智能合约必须要有分片的意识（参见2.3.18和2.3.16）。 通常（本地）智能合约可以是无需考虑分片的。

15. TVM 支持闭包。

16. 可以在TVM内轻松实现“spineless tagless G-machine”。

除了“TVM 汇编语言”之外，还可以为 TVM 设计几种高级语言。 所有这些语言都将具有静态类型，并将支持代数数据类型。 我们设想了以下可能性：

1. 一种类似Java的命令式语言，每个智能合约类似于一个单独的类。

2. 一种惰性函数式语言（类似 Haskell）。

3. 一种快速的函数式语言（类似 ML）。

### 2.1.21 可配置参数

TON 区块链的一个重要特征是它的许多参数都是可配置的。 这意味着它们是主链状态的一部分，并且可以通过主链中的某些特殊提议/投票/结果交易进行更改，而无需任何硬叉。 改变这些参数将需要三分之二的验证人投票和所有其它支持该修改提议的一半以上参与者投票。

## 2.2 TON 区块链的一般概括

### 2.2.1 区块链的一般定义

通常，区块链是一系列首尾相连的块，每个块 B 包含前一个块(blk-prev [B])的引用 （通常通过将前一个块的 HASH 包含在当前块的头部中），以及交易清单。 每个交易描述了全局区块链状态的一些转换; 按顺序将块中的每个交易以某个算法计算，即可获得该块的最新状态。

### 2.2.2 TON 区块链的相关性

回想一下，TON Blockchain 不是传统意义的区块链，而是二维区块链的集合（即区块链的区块链;参见2.1.1），因此上述内容并不直接适用于 TON Blockchain。 但是，我们从传统区块链的这些一般性开始，将其用于构造更复杂结构的系统。

### 2.2.3 区块链实例和区块链类型

人们经常使用区块链这个词来表示一般的区块链类型及其特定的区块链实例。 例如，2.2.1 指的区块链实例。

以这种方式，区块链类型通常是块的列表（即，有限序列）的块(Block<sup>\*</sup>)类型的“子类型”，由满足某些兼容性和有效性条件的那些块序列组成：

> (式1) Blockchain ⊂ Block<sup>\*</sup> 

定义区块链的更好方法是将区块链看作是依赖的耦合类型，由耦合（B，v）组成，第一个组件 B: Block<sup>\*</sup> 是 Block<sup>\*</sup>  列的类型，以及 第二部分 v: isValidBc（B）是B的有效性的证明或见证。如下：

> (式2) Blockchain ≡ Σ<sub>(B:Block<sup>\*</sup>)</sub>*isValidBc*(B)

我们在这里使用从引用[16]的类型依赖和表示法。

### 2.2.4 依赖类型论， Coq 和 TL

请注意，我们在这里使用（Martin-Löf）依赖类型论，类似于在 [Coq](https://coq.inria.fr) 中使用的理论。

依赖类型论的简化版本也用在TL ([Type Language](https://core.telegram.org/mtproto/TL)) ，其将用于 TON 区块链的正式规范中以描述所有数据结构的序列化以及块，交易等的设计。

实际上，依赖类型论给出了证明是什么的有用形式化，例如，当需要为某些块提供无效证明时，这种形式证明（或它们的序列化）可能变得很方便。

### 2.2.5 类型语言 (TL)

由于 TL（类型语言）用于TON 区块、交易和网络数据报的正式规范，因此需要进行简短的讨论。

TL 是一种适用于从属代数类型描述的语言，允许使用数值和类型参数。 通过几个构造函数描述每种类型。 每个构造函数都有一个可读的标识符和一个名称。 除此之外，构造函数的定义包含字段列表及其类型。

构造函数和类型定义的集合称为 TL Scheme。 它通常保存在一个或多个带有后缀 .tl 的文件中。

TL Scheme 的一个重要特征是它确定了一种明确的方式来序列化和反序列化代数类型的值（或对象）。 也就是说，当需要将值序列化为字节流时，首先序列化用于此值的构造函数的名称。之后递归地序列化每个字段。

适用于将任意对象序列化为32位整数序列的 TL 的先前版本的描述可在 https://core.telegram.org/mtproto/TL 获得。 一种名为 TL-B 的 TL 新版本也正在开发，其用于描述 TON 项目的对象序列化。 这个新版本可以将对象序列化为字节流甚至比特流（不仅仅是32位整数），并且支持序列化到 TVM 单元树中（参见2.3.14）。 TL-B 的将是 TON 区块链的正式规范的一部分。

### 2.2.6 区块和交易是状态转换运算符

通常，任何区块链都具有关联的全局状态和交易。 区块链的语义在很大程度上取决于事务函数：

> (式3) *ev_trans′* : Transaction × State → State<sup>\?</sup>

X<sup>\?</sup> 代表 MAYBE X，即把 MAYBE 应用单子 X 的结果。本质上，类型 X<sup>\?</sup> 的值是类型 X 的值或特殊值 ⊥ （表示缺少实际值）。在我们的例子中，我们使用 State<sup>\?</sup> 而不是State 作为结果类型，这是因为如果从某些原始状态调用交易可能是无效的（比如试图从账户中提取比实际存在的更多的钱）。

我们可能更倾向于柯理化的方式表达：

> (式4) *ev_trans* : Transaction → State → State<sup>\?</sup>

因为区块本质上是一个交易列表，所以可以从 *ev_trans* 导出区块评估函数：

> (式5) *ev_block* : Block → State → State<sup>\?</sup>

它表示一个块 B:Block 和前一个区块链状态 s:State（可能包括前一个块的哈希值）并计算下一个区块链状态 `s'= ev_block(B)(s)`，其计算结果可能是 True 或为特殊值⊥（表示无法计算下一个状态。即，如果从给定的起始状态进行计算，则该区块无效 - 例如，该块包括试图从空账户中扣款的交易。）。

### 2.2.7 区块序列号

区块链中的每个块 B 可以通过其序列号 BLK-SEQNO(B) 来引用，从第一个块(0)开始，并且每当传递到下一个块时递增1。 

> (式6) BLK-SEQNO(B) = BLK-SEQNO(BLK-PREV(B)) + 1 

请注意，在存在分支时序列号不会唯一地标识块。

### 2.2.8 区块 HASH

引用块 B 的另一种方式是通过其散列 BLK-HASH(B)来引用，其实际上是块 B 头部的散列（然而，块的头部通常依赖于块 B 的所有内容的散列）。 假设所使用的散列函数没有冲突（或者至少它们是非常不可能的），则通过其散列唯一地标识块。


### 2.2.9 计算 HASH

在对区块链算法进行正式分析前，我们假设使用没有冲突的 k 位散列函数 HASH: Bytes<sup>\*</sup>→2<sup>k</sup>:

> (式7) Hash(s) = Hash(s′) ⇒ s = s′  // for any s, s′ ∈ Bytes<sup>\*</sup> 

这里 Bytes = {0...255} = 2^8 是字节类型，或者是所有字节值的集合，Bytes<sup>\*</sup> 是任意（有限）字节列表的类型或集合; 而2 = {0,1} 是比特类型，而 2<sup>k</sup> 是所有 k 比特序列（即，k比特数）的集合。

当然，(式7) 在数学上是不可能的，因为从无限集到有限集的映射不能是单射的。 一个更严格的假设是:

(式8) ∀s, s′ : s ≠ s′, P (Hash(s) = Hash(s′)) = 2<sup>−k</sup>

但是，这对于证明来说并不方便。 对于某些小ε（例如，ε= 10<sup>-18</sup>），只要我们接受失败概率 ε（即，最终结论将是真实的，概率至少为1  - ε），那么如果（式8）在 2<sup>-k</sup>N < ε 的证明中最多使用 N 次，则我们可以推理（式7）为真。

最后结论：为了使（式8）的概率陈述真正严格，必须在所有字节序列（Byte<sup>*</sup>）的设置上引入概率分布。这样做的一种方法是假设所有相同长度的字节序列都是等概率的，并设置观察长度 l 的序列的概率等于p<sup>l</sup> − p<sup>l+1</sup>。然后（式8）应该被理解为当 p 从向于 1 时的条件概率 `P(Hash(s) = Hash(s′)|s ≠ s′)` 的极限。

### 2.2.10 TON 区块链中使用的 HASH

我们暂时使用 SHA256 作为 TON 区块链的哈希算法。 如果无法满足未来需求，那么将来也可以用另一个哈希函数替换它。 散列函数的选择是协议的可配置参数，因此可以在没有硬分叉的情况下进行更改，如2.1.21中所述。

## 2.3 区块链状态，账户和哈希表

我们在上面已经提到，任何区块链都定义了某个全局状态，每个区块和每个交易都定义了这个全局状态的转换。 这里我们描述 TON 区块链使用的全局状态。

### 2.3.1 账户ID

TON 区块链使用的基本帐户ID（至少是主链和 0 号工作链）使用的是 256 位整数，我们假设它是特定椭圆曲线的 256 位公钥。 

(式9) account_id : Account = uint<sub>256</sub> = 2^256

此处 Account 是帐户类型，而 account_id 是帐户类型的特定变量。

其他工作链可以使用其他帐户 ID 格式。 例如，可以使用比特币风格的帐户 ID，也就是 ECC 公钥的 SHA256。

但是，在创建工作链时必须固定帐户 ID 的位长 l，并且它必须至少为64，因为 account_id 的前64位用于分片和消息路由。

### 2.3.2 重要组件 —— 哈希表（哈希映射）

TON 区块链状态的主要组成部分是哈希表。在一些情况下，我们定义“映射” h: 2<sup>n</sub> -> 2<sup>m</sup>。更一般地说，我们可能对复合类型 X 的哈希映射 h: 2<sup>n</sup> -> X 感兴趣。但是，索引类型几乎总是 2<sup>n</sup>。

有时候，我们有一个空“默认值”: X，而哈希表 h: 2<sup>n</sup> -> X 由其“默认值” i → "empty" 初始化。

### 2.3.3 示例: TON 帐户余额

TON 账户余额给出了一个重要的例子。 这是一个哈希映射:

(式10) balance : Account → uint<sub>128</sub>

它表示 Account 的 uint<sub>128</sub> 余额。此哈希映射的默认值为零，这意味着最初（在处理第一个块之前）所有帐户的余额为零。

### 2.3.4 示例：智能合约的持久化存储

另一个例子是智能合约的持久化存储，它可以（非常近似地）表示为哈希映射:

(式11) storage : 2<sup>256</sup> -> 2<sup>256</sup>

此映射也具有默认值零，这意味着未初始化的持久存储单元为零。

### 2.3.5 示例：所有智能合约的持久化存储

因为我们有多个智能合约，分别由 account_id 区分，每个都有独立的持久化存储，因此我们必须有一个哈希表：

(式12) Storage : Account -> (2<sup>256</sup> -> 2<sup>256</sup>)

将智能合约的 account_id 映射到持久化存储中。

### 2.3.6 哈希映射类型

哈希映射不仅仅是一个抽象的（部分定义的）函数 2<sup>n</sup> -> X; 它有一个规范的表示。因此，假设我们有一个特殊的哈希映射类型:

> (式13) Hashmap(n,X) : Type

对应于（部分）数据结构的编码映射 2<sup>n</sup> -> X。我们也可以写

> (式14) Hashmap(n : nat)(X : Type) : Type

或

> (式15) Hashmap : nat → Type → Type

我们总是可以将 h: Hashmap(n, X) 转换为映射 hget(h): 2<sup>n</sup> -> X<sup>\?</sup>。从此以后，我们通常写 h[i] 而不是 hget(h)(i):

(式16) h[i] :≡ hget(h)(i) : X<sup>\?</sup> for any i: 2n, h: Hashmap(n,X)

### 2.3.7 将哈希映射类型定义为 Patricia 树

从逻辑上讲，可以将 Hashmap(n, X) 定义为深度为 n 的（不完整）二叉树，边缘标为 0 和 1，叶节点的值为 X。 描述相同结构的另一种方式是对于长度等于 n 的二进制串（按位）trie。

在实践中，我们更喜欢使用 trie 的紧凑表示，通过压缩每个顶点，使只有一个子节点对应其父节点。 其结果表示称为 Patricia 树或二进制基数树。 现在每个中间顶点都只有两个由非空二进制字符串标记的子节点，左边的子节点为零，右边的子节点为1。

换句话说，Patricia 树中有两种类型的（非根）节点:

1. Leaf(x)，包含 X 类型的值 x。

2. Node(l, s<sub>l</sub>, r, s<sub>r</sub>)，其中 l 引用左子节点或子树，s<sub>l</sub> 是标记连接此顶点到其左子节点的边的位串（始终以0开头），r是右子树，s<sub>r</sub> 是标记连接此顶点到右子节点的位串（总是以1开头）。

第三种类型的节点，仅用于 Patricia 树的根节点：

1. Root(n, s<sub>0</sub>, t)，其中 n 是 Hashmap(n, X) 的索引位串的公共长度，s<sub>0</sub> 是所有索引位串的公共前缀，t 是对 Leaf 或 Node 的引用。

如果我们想让 Patricia 树为空，那么需要使用第四种类型的（根）节点：

1. EmptyRoot(n)，其中n是所有索引位串的公共长度。

我们通过下式定义 Patricia 树的高度：

> (式17) HEIGHT(LEAF(x)) = 0

> (式18) HEIGHT(NODE(l, s<sub>l</sub>, r, s<sub>r</sub>)) = HEIGHT(l) + LEN(s<sub>l</sub>) = HEIGHTt(r) + LEN(s<sub>r</sub>)

> (式19) HEIGHT(Root(n, s<sub>0</sub>, t)) = LEN(s<sub>0</sub>) + HEIGHT(t) = n

最后两个公式中每个公式中的最后两个表达式必须相等。 我们使用高度为 n 的 Patricia 树来表示 Hashmap(n, X) 类型的值。

如果树中有 N 个叶子（即我们的 Hashmap 包含 N 个值），则恰好有 N-1 个中间顶点。 插入新值总是涉及通过在中间插入新顶点并添加新叶作为此新顶点的另一个子节点来分割现有边。 从散列映射中删除值则相反：删除了一个叶子及其父级，并且父级的父级和另一个子级直接链接。

### 2.3.8 Merkle-Patricia 树

使用区块链时，我们希望能够能将它们化减为单个哈希值来比较 Patricia 树（即哈希图）及其子树。Merkle 树给出了实现这一目标的经典方法。 本质上，我们需要借助为二进制字符串定义的散列函数，才能计算对象的散列 Hash(x) x: X 的二进制序列化，而达到我们想要描述一种散列 Hashmap(n, X) 类型的对象 h 的方法。

可以递归地定义 Hash(h)，如下所示：

> (式20) Hash(Leaf(x)) := Hash(x)

> (式21) Hash((l, s<sub>l</sub>, r, s<sub>r</sub>)) := Hash(Hash(l). Hash(r). Code(s<sub>l</sub>). Code(s<sub>r</sub>))

> (式22) Hash(Root(n, s<sub>0</sub>, t)) := Hash(Code(n). Code(s<sub>0</sub>). Hash(t))

这里 s.t 表示（位）字符串 s 和 t 的串联，并且 Code(s) 是所有位串 s 的前缀代码。

稍后我们将看到（参见2.3.12和2.3.14）这是一个（稍微调整过的）递归定义的哈希值，用于任意（从属）代数类型的值。

### 2.3.9 重新计算 Merkle 树的哈希值

这种递归定义 Hash(h) 的方式，称为 Merkle 树哈希，具有以下优点：如果显式地存储 Hash(h') 以及每个节点 h'（例如，一个 Merkle-Patricia 树）在添加删除或更改元素时仅需要最多重新计算 n 个哈希值。

这样，如果通过合适的 Merkle 树哈希表示全局区块链状态，则在每次交易发生后很容易重新计算此哈希状态。

### 2.3.10 Merkle 证明

在式7的假设下，可以构造一个证明，对于给定值 z 的 Hash(h)， h: Hashmap(n, X)，对于某些 i: 2n 和 x: X 可得 hget(h)(i) = x。这样的证明将涵盖 Merkle-Patricia 树中从对应于 i 到根的路径，且在该路径上的所有节点以及所有兄弟节点的哈希。

以这种方式，轻节点就可以从全节点那里获取部分信息证明数据的有效性。

在一些情况下，客户端可能想要获得值 y = Hash(x) = Hash(h[i]) 而不是散列图本身， 那么可以提供 (i，y) 的 Merkle 证明。 如果 x 也是哈希图，则可以从全整节点获得开始从 y = Hash(x) 的 Merkle 证明，以提供值 x[j] = h[i][j] 或仅哈希值。

### 2.3.11 对于 TON 这样的多链系统，Merkle 证明的重要性

请注意，节点通常不是 TON 中存在的所有分片链的完整节点。节点通常只是一些分片链的完整节点（那些包含自己的帐户，它感兴趣的智能合约，或者这个节点被指定为验证人的那些）。对于其他分片链，它一定是一个轻节点，否则存储，计算和网络带宽要求将是令人望而却步的。这意味着这样的节点不能直接检查关于其他分片链状态; 它必须依赖从完整节点获得的那些分片链的 Merkle 证明，通常这与自我验证一样安全，除非 (式7) 失败 （比如 Hash 冲突）。

### 2.3.12 TON VM 的特点

用在主链和零工作链中运行智能合约的 TON VM 或 TVM（Telegram Virtual Machine）与受 EVM（Ethereum Virtual Machine）启发的传统设计有很大不同。TVM 不仅适用于 256 位整数，而实际上适用于（几乎）任意“数值”，“结构”或“和积类型”，使其更适合执行高级（特别是函数式）语言。 从本质上讲，TVM 使用标记数据类型，与 Prolog 或 Erlang 的实现中使用的数据类型不同。

人们可能首先想到的是，TVM 智能合约的状态不仅仅是一个散列图，而是 Hashmap(256, X)，X 是具有多个构造函数，使其能够存储除 256 位整数之外的其他数据结构的类型，特别是包括其它 Hashmap(256, X)。这意味着 TVM（持久或临时）存储的单元，或 TVM 智能合约代码中的变量或数组元素不仅可以包含整数，而且可以包含全新的散列映射。当然，这意味着一个单元不仅有 256 位，而且还包含一个 8 位标签，用于描述如何解释这 256 位。

实际上，值不需要精确为 256 位。 TVM 使用的值格式由一系列原始字节和对其他结构的引用组成，以任意顺序混合，一些描述符字节插入合适的位置，以便能够区分指针与原始数据（例如，字符串或整数）; 参见2.3.14。

该原始值格式可用于实现任意和积代数类型。 在这种情况下，该值首先包含一个原始字节，描述正在使用的“构造函数”（从高级语言的角度来看），然后是其他“字段”或“构造函数参数”，由原始字节组成 并根据所选的构造函数引用其他结构（参见2.2.5）。  但是，TVM 对构造函数与其参数之间的对应关系一无所知; 字节和引用的混合由某些描述符字节显式描述。

Merkle 树散列扩展到任意这样的结构：为了计算这种结构的散列，所有引用都被递归的对象散列替换，然后计算得到的字节串（包括描述符字节）的散列。

通过这种方式，2.3.8 中描述的用于散列图的 Merkle 树散列，只是对任意（从属）代数数据类型应用于具有两个构造函数的 Hashmap(n, X) 类型进行散列的特殊情况。

### 2.3.13 TON 智能合约的持久化存储

TON 智能合约的持久化存储基本上由其“全局变量”组成，在智能合约的调用之间保留。 因此，它只是一个由正确类型的字段组成的 "product"，"tuple" 或 "record" 类型，每个字段对应一个全局变量。 如果全局变量太多，则由于对 TON 单元大小的全局限制，它们不能存放进一个 TON 单元。 在这种情况下，它们被分成若干记录并组织成树，基本上成为 "product of products" 或 "product of products of products" 类型，而不仅仅是 "product" 类型。

### 2.3.14 TVM 单元

TON VM 将所有数据保存在（TVM）单元集合中。 每个单元首先包含两个描述符字节，指示该单元中存在多少字节的原始数据（最多 128 个）以及存在多少个对其他单元的引用（最多 4 个）。 然后是这些原始数据字节和其它单元引用。 每个单元格只引用一次，因此我们可能在每个单元格中也包含对其“父”单元的引用。

以这种方式，TON 智能合约的持久化数据存储单元被组织成树，其中引用了保存在智能合约描述中的该树的根。 如有必要，从叶节点开始递归计算整个持久化存储器的 Merkle 树哈希，然后递归替换掉引用单元，并随后计算由此获得的数据的哈希值。

### 2.3.15 任意代数类型值的广义Merkle证明

因为 TON VM 通过由（TVM）单元组成的树来表示任意代数类型的值，并且每个单元具有明确定义的（根据该单元格生成的整个子树的） Merkle 哈希， 所以我们可以为任意代数类型的（部分）值提供“广义 Merkle 证明”，旨在证明具有已知 Merkle 散列的树的某个子树采用特定值或具有特定散列的值。 这概括了2.3.10其中只考虑了 x[i] = y 的 Merkle 证明。

### 2.3.16 TON VM 数据结构中的分片支持

我们刚刚概述了 TON VM 如何在不过度复杂的情况下支持高级智能合约语言中的任意（相关）代数数据类型。 但是，大型（或全局）智能合约的分片需要在 TON VM 级别上提供特殊支持。 为此，系统中添加了特殊版本的 Hashmap 类型，相当于“映射” Account -> X. 这个“映射”似乎等同于 Hashmap(m, X)，其中 Account = 2<sup>m</sup>。 但是，当分片分成两个子分片或两个分片合并时，这些 Hashmap 会自动拆分为两个或合并回来，以保留属于相应分片的那些 Key。

### 2.3.17 为持久化存储支付

TON 区块链的一个值得注意的特征是从智能合约中支付用于其持久化的数据存储（例如，扩大区块链的状态）。 它的工作原理如下：

每个块声明两个价格（通常是用 Gram 计价）：将一个单元保留在持久化存储中的价格，以及在持久化存储的某个单元中保留一个原始字节的价格。 每个帐户使用的单元和字节总数的统计信息存储为其状态的一部分，因此通过将这些数字乘以块中声明的两个费率，我们可以计算出要从帐户余额中扣除的付款以便保留它在前一个块和当前块之间的数据。

但是，对于每个帐户和每个块中的智能合约，不强制要求为持久化存储付款; 相反，该支付最后被执行的块的序列号存储在帐户数据中，并且当对该帐户进行任何操作时（例如，通过智能合约接收和处理价值转移或消息）， 自执行任何进一步操作之前从帐户余额中扣除上一次此类付款以来所有块的存储使用付款。 如果此后帐户的余额将变为负数，则该帐户将被销毁。

工作链可以声明每个帐户的一些原始数据字节是“免费”的，以便于创建 "simple" 帐户，这些帐户仅保留一个或两个加密货币，以免除这些付款。

请注意，如果没有人向帐户发送任何消息，则不会收集其持久化存储的费用，并且它可以无限期地存在。 但是，任何人都可以发送一条空消息来销毁这样的帐户。这样，要销毁的帐户的原始余额的一部分会被收集起来，以激励这样的消息的发送者。 但是，我们预计验证人将免费销毁此类无力偿债的账户，只是为了减少全局区块链的规模，以避免在没有补偿的情况下保留大量数据。

### 2.3.18 本地和全局智能合约；智能合约实例

根据智能合约 account_id 确定的智能合约通常只存在于一个分片中，这和“普通”账户类似。 对于大多数应用来说，这通常就足够了。 然而，一些“高负荷”的智能合约可能希望在某些工作链的每个分片链中都有一个“实例”。 为了实现这一点，必须将它们的创建交易传播到所有分片链中，并支付大笔手续费。

此操作有效地在每个分片中创建智能合约的实例，并具有单独的余额。 最初，在创建交易中传输的余额只是通过在 shard(w, s) 中给出 2<sup>-|s|</sup> 的总余额一部分来分配。 当分片分成两个子分片时，所有全局智能合约实例的余额分成两半; 当两个分片合并时，余额会加在一起。

在某些情况下，拆分/合并全局智能合约的实例可能涉及（延迟）执行这些智能合约的特殊方法。 默认情况下，如上所述拆分和合并余额，以及一些特殊的“帐户索引”哈希表也会自动拆分和合并（参见2.3.16）。

### 2.3.19 智能合约的拆分限制

全局智能合约可能会在创建时限制其拆分深度 d，以便使持久化存储费用更具可预测性。 这意味着，如果 shardchain(w, s) 与 |s| ≥ d 分为两部分，两个新的分片链中只有一个继承了智能合约的一个实例。 对这种情况有明确的定义：每个全局智能合约都有一些 account_id，它本质上是其创建交易的哈希值，并且其实例具有相同的account_id，其中第一个 ≤d 位替换为正确分片所需的适当值。 在拆分后的该 account_id 分片将继承智能合约实例。

### 2.3.20 账户/智能合约状态

我们可以总结以上所有内容，得出结论：帐户或智能合约状态包含以下内容：

1. 基础货币的余额
2. 其他货币的余额
3. 智能合约代码（或其哈希）
4. 智能合约的持久化数据（或其Merkle哈希）
5. 有关持久化存储单元数和使用的原始字节数的统计信息
6. 智能合约持久存储的付款的最近时间（实际上是主链块号）
7. 转移货币并从此帐户发送消息所需的公钥（可选; 默认情况下等于 account_id 本身）。 在某些情况下，类似于比特币交易输出所做的，可以在此处找到更复杂的签名检查代码; 然后 account_id 将等于此代码的哈希值。

我们还需要在帐户状态或其他一些帐户索引的 Hashmap 中保留以下数据：

1. 帐户的输出消息队列（参见2.4.17）
2. 最近发送消息的哈希值（参见2.4.23）

并非所有的信息都是每个帐户必须需要的; 例如，智能合约代码仅适用于智能合约，但不适用于“简单”账户。 此外，虽然任何账户必须具有主要货币的非零余额（例如，基本工作链的主链和分片链的 Gram），但其它货币的余额可能为零。 为了避免保留未使用的数据，在工作链的创建期间定义了一个 sum-product 类型，它使用不同的标记字节（例如，TL构造函数;参见2.2.5）来区分不同的“够造函数“。 最终，帐户状态本身被保存为 TVM 持久化存储的单元集合。

## 2.4 分片链之间的消息

TON 区块链的一个重要组成部分是区块链之间的消息传递系统。 这些区块链可以是相同工作链的分片链，也可以是不同工作链的分片链。

### 2.4.1 消息，帐户和交易的概览

消息从一个帐户发送到另一个帐户。 每个交易包括一个接收该消息的帐户，根据某些规则更改其状态，以及向其他帐户生成多个（可能是一个或零个）新消息。 每条消息都会生成并接收（传递）一次。

这意味着消息在系统中起着至关重要的作用，与帐户（智能合约）相当。 从无限分片范式（参见2.1.2）的角度来看，每个帐户都在其独立的“帐户链”中，并且它影响其他帐户状态的唯一方法是发送消息。

### 2.4.2 账户作为参与者 —— 参与者模型(Actor Model)

有人可能会将帐户（和智能合约）视为“流程”或“参与者”，它们能够处理传入的消息，更改其内部状态并生成一些出站消息。 这与所谓的 Actor 模型密切相关，在 Erlang等语言中使用（然而，Erlang中的actor通常称为 "processes"）。 由于处理入站消息的结果也允许现有参与者创建新的参与者（即，智能合约），因此与 Actor 模型的对应基本上是完整的。

### 2.4.3 消息接收者

任何消息都有其接受者，其特征是目标工作链标识符 w（默认情况下假定与发起的分片链相同）和收件人帐户 account_id。 account_id 的确切格式（即比特数）取决于 w; 但是，分片始终由其第一个（最重要的） 64 位确定。

### 2.4.4 消息发送者

在大多数情况下，消息具有发送者，再次由 (w', account_id') 表示。 如果存在，则它位于消息收件人和消息值之后。 有时，发送者不重要或者不属于区块链（即，不是智能合约），在这种情况下，该字段不存在。

请注意，Actor 模型不要求消息具有隐式发送方。 相反，消息可以包含对应该发送请求的 Actor 引用，通常它与发送者一致。 但是，在加密货币（拜占庭）环境中的消息中具有显式的不可伪造的发送者字段是有用的。

### 2.4.5 消息（价）值

消息的另一个重要特征是其附带的消息（价）值，由源和目标工作链支持的一个或多个加密货币。 消息的值在消息接收者之后立即显示; 它本质上是 (currency_id, value) 对的列表。

请注意，“简单”帐户之间的“简单”值转移只是空（无操作）消息，并附加了一些（价）值。 另一方面，稍微复杂的消息体可能包含简单的文本或二进制注释（例如，关于支付的目的）。

### 2.4.6 外部消息，或“来自任意地方的消息”

有些消息“无处不在”地进入系统 - 也就是说，它们不是由位于区块链中的帐户（智能合约或非智能合约）生成的。 当用户想要将一些资金从她控制的账户转移到其他账户时，就会出现最典型的例子。 在这种情况下，用户将“来自任何地方的消息”发送到她自己的帐户，请求它生成带有指定值的接收帐户的消息。 如果此消息已正确签名，则她的帐户会收到该消息并生成所需的出站消息。

实际上，人们可能会将“简单”帐户视为具有预定义代码的智能合约的特例。 这个智能合约只接受一种消息。 这样的入站消息必须包含由入站消息而生成的出站消息列表以及签名。 智能合约检查签名，如果正确，则生成所需的消息。

当然，“来自任意地方的信息”与正常信息之间存在差异，因为“来自任意地方的信息”不能承担价值，因此它们不能自己支付它们的 "Gas"。 相反，在被收集到新的区块之前，他们暂时执行了一小段代码; 如果执行失败（签名不正确），则“来自任意地方的消息”被认为是不正确的并被丢弃。 如果执行没有失败，则该消息可以包括在新的区块中并且完全处理，并从接收者的账户中扣除 Gas 的费用。 “来自任意地方的消息”还可以定义一些交易费，用于再分配给验证人的燃料费，该费用在接收方的帐户中扣除。

在这个意义上，“来自任意地方的消息”或“外部消息”承担在其他区块链系统（例如，比特币和以太坊）中交易候选者的角色。

### 2.4.7 日志消息，或“去往任意地方的消息”

类似地，有时可以生成特殊消息并将其路由到特定的分片链，不是将其传递给其接收者，而是记录以便任何人都可以容易地观察到。 这些日志消息可以在用户的控制台中输出，或者触发在 off-chain 服务器上执行某些脚本。 从这个意义上讲，它们代表了“区块链超级计算机”的外部“输出”，就像“来自任意地方的消息”代表“区块链超级计算机”的外部“输入”一样。

### 2.4.8 与 off-chain 服务和外部区块链交互

这些外部输入和输出消息可用于与链下(off-chain)服务和其他（外部）区块链（如比特币或以太网）进行交互。 有人可能会在 TON Blockchain 内部创建 Token 或其它加密货币，这些货币链与比特币，Ethers 或以太网区块链中定义的任何 ERC-20 代币挂钩，并使用“来自任意地方的消息”和“去往任意地方的消息”，由脚本生成和处理 驻留在某些第三方链下服务器上，以实现 TON 区块链与这些外部区块链之间的必要交互。

### 2.4.9 消息体

消息体只是一个字节序列，其含义仅由接收工作链和/或智能合约确定。 对于使用 TON VM 的区块链，可以通过被 Send() 生成的任何 TVM 单元自动序列化。 最终，出现一串通常由 4 字节“消息类型”或“消息构造函数”作为前缀的原始字节，用于选择接收智能合约的正确方法。

另一种选择是使用 TL 序列化对象（参见2.2.5）作为消息体。 这对于不同工作链之间的通信尤其有用，其中一个或两个工作链不一定使用 TON VM。

### 2.4.10 Gas 限制和其他工作链/VM特定参数

有时，消息需要携带有关 Gas 限制，Gas 价格，交易费用和依赖仅与接收工作链相关的货币信息。并且，这些参数包含在消息体中或之前，有时（取决于工作链）具有特殊的4字节前缀表明它们的存在（可以通过TL方案定义;参见2.2.5）。

### 2.4.11 创建消息：智能合约和交易

新消息来源主要有两个。 大多数消息是在智能合约执行期间（通过 TON VM 中的 Send() ）创建的，此时调用某个智能合约来处理传入消息。 或者，消息可能来自外部，作为“外部消息”或“来自任意地方的消息”（参见2.4.6）。

### 2.4.12 消息分发

当消息到达包含其目标帐户的分片链时，它将被“传递”到其目标帐户。 接下来会发生什么取决于工作链; 从外部的角度来看，重要的是这样的消息永远不能从这个分片链进一步转发。

对于基本工作链的分支链，消息附带的价值（减去任何 Gas 费用）将添加到接收帐户的余额中，并且如果接收帐户是智能合约就可能在之后调用接收智能合约消息的相关方法。 实际上，智能合约只有一个用于处理所有传入消息的入口点，它必须通过查看它们的前几个字节来区分不同类型的消息（例如，包含TL构造函数的前四个字节;参见2.2.5）。

### 2.4.13 交易是消息分发的载体

因为消息的传递改变了帐户或智能合约的状态，所以它是分片链中的特殊交易。 基本上，所有 TON 区块链交易都包括向其接收账户（智能合约）交付一个入站消息（忽略一些小的技术细节）。

### 2.4.14 同一智能合约实例之间的消息

回想一下，智能合约可能是本地的（即，像任何普通账户一样驻留在一个分片链中）或全局的（即，在所有分片中具有实例，或者至少在所有分片中具有某个已知深度 d ;参见2.3.18）。 如果需要，全局智能合约的实例可以交换特殊消息以在彼此之间传递信息和价值。 在这种情况下，（不可伪造的）发件人 account_id 变得很重要（参见2.4.4）。

### 2.4.15 发送给任何智能合约实例的消息; 通配符地址

有时，消息（例如，客户端请求）需要被传递到全局智能合约的任何实例，通常是最接近的一个实例（例如，如果存在与发送者相同的分片链中的一个，则它是明显的候选者）。 一种方法是使用“通配符收件人地址”，允许目标 account_id 的前 d 位采用任意值。 实际上，通常会将这些 d 位设置为与发送方的 account_id 中相同的值。

### 2.4.16 不存在输入队列

由区块链（通常是分片链; 有时是主链）接收的所有消息 - 或者由驻留在某个分片链内的“帐户链”立即分发（即，由接收帐户处理），因此，没有“输入队列”。 相反，由于块的总大小和 Gas 使用的限制，并非所有发往特定分片链的消息都可以被处理，则一些消息只能被累积在原始分片链的输出队列中。

### 2.4.17 输出队列

从无限分片范例（参见2.1.2）的角度来看，每个账户链（即每个账户）都有自己的输出队列，包括它已生成但尚未发送给收件人的所有消息。 当然，账户链只是虚拟存在; 它们被分组到分片链中，而分片链有一个输出“队列”，它由属于分片链的所有帐户的输出队列的并集组成。

此分片链输出“队列”仅对其成员消息部分顺序。 也就是说，前一个块中的消息必须在后续块之前被分发，并且同一帐户生成任何消息必须按照它们生成的顺序传递。

### 2.4.18 快速可靠的链间消息传递

对于像 TON 这样的可扩展多区块链项目来说，能够在不同的分片链之间转发和传递消息（参见2.1.3）是至关重要的。 消息应该可靠地（即，消息不应丢失或不止传送一次）并且快速传送。 TON 区块链通过结合使用两个“消息路由”机制实现了这一目标。

### 2.4.19 超立方路由：确保消息传递的“缓慢通道”

TON 区块链使用“超立方路由”(hypercube routing)作为一种缓慢但安全可靠的方式，将消息从一个分片链传递到另一个分片链，如有必要，可使用多个中间分片链进行传输。 如果不通过这种方式，那么任何给定的分片链的验证人都需要跟踪所有其他分片链的状态（输出队列），这将需要大量的计算能力和网络带宽，因为随着分片链的总量增长，系统的可扩展性会受到更多限制。 因此，无法直接从任何分片向其他分片传递消息。 相反，每个分片仅“连接”到不同于其 (w, s) 分片标识符的一个十六进制数字的分片（参见2.1.8）。 这样，所有的分片链都构成了一个“超立方体”，并且消息沿着这个超立方体的边缘传播。

如果将消息发送到与当前分片不同的分片，则当前分片标识符的一个十六进制数字（确定性地选择）将被目标分片的相应数字替换，并且所得到的标识符将用作消息转发的最近目标分片。

超立方体路由的主要优点是验证人必须收集并处理来自“相邻”分片链的输出队列的消息，以免丢失它们的权益。 通过这种方式，可以预期任何消息迟早会到达其最终目的地; 消息不会在传输过程中丢失或交付两次。

请注意，超立方体路由引入了一些额外的延迟和费用，因为必须通过几个中间的分片链转发消息。 然而，这些中间分片链的数量增长非常缓慢。

### 2.4.20 即时超立方路由：消息传递的“快速通道”

TON 区块链的一个新特点是它引入了一条“快速通道”，用于将消息从一个分片链转发到任何其他分片链，允许在大多数情况下完全绕过 2.4.19 的“慢”超立方体路由并将消息传递到最后一个目的分片链的下一个区块。

在“慢”超立方体路由中，消息沿着超立方体的边缘（在网络中）传播，但会在每个中间节点处延迟大约五秒后继续在传播到相应的分片链中。

为了避免不必要的延迟，可以使用沿超立方边缘的适当 Merkle 证明来中继消息，而无需将其提交到中间的分片链中。 实际上，网络消息应该从原始分片的“任务组”（参见2.6.8）的验证人转发到目标分片的指定块生成者的“任务组”中（参见2.6.9）。 这可以不需要沿着超立方体的边缘传递而直接完成。 当带有 Merkle 证明的消息到达目的分片的验证人时，它们可以立即将其提交到新的块中。 然后沿着超立方体边缘发送回传确认以及合适的 Merkle 证明，并且可以通过提交特殊交易来用于停止消息的传递。

请注意，这种“即时分发”机制并不能取代 2.4.19 中描述的“慢速”机制。 因为验证器不能因丢失或决定不将“快速通道”消息提交到其区块链的新块而受到惩罚，所以仍然需要“慢速通道”。

因此，两种消息分发方法都是并行运行的。只有在将“快速”机制的消息成功提交到中间分片链时才会中止“慢速”机制。

### 2.4.21 从邻近的分片链的输出队列中收集输入消息

当分片链的新块产生时，相邻分片链的一些输出消息将会作为“输入”消息被包括在新块中并立即传送（处理）。 存在某些规则来处理这些邻居的输出消息的顺序。 基本上，任何“较旧”消息会在“较新”消息之前被传递; 而对于来自相同的相邻分片链的消息，必须遵守2.4.17中描述的顺序。

### 2.4.22 从输出队列中删除消息

一旦观察到输出队列消息已经被相邻的分片链传递，它就会被特殊的消息从输出队列中显式删除。

### 2.4.23 防止消息双重传递

为了防止从相邻分片链的输出队列中获取的消息双重传递，每个分片链（更确切地说，其中的每个帐户链）将最近传递的消息（或仅仅是它们的哈希）的集合保持为其状态的一部分。 当观察到传递的消息由其始发的相邻分片链从输出队列中删除时（参见2.4.22），它也会从最近传递的消息的集合中删除。

### 2.4.24 转发用于其它分片链的消息

超立方路由（参见2.4.19）意味着有时出站消息不会传递到包含预期接收者的分片链上，而是传递到位于目的地分片链的相邻分片链上。 在这种情况下，“传递”是指将入站消息移动到出站队列。 这在块中显式地反映为包含消息本身的特殊转发消息。 从本质上讲，这看起来好像是分片链中的某个人收到了消息，并且结果生成了一条相同的消息。

### 2.4.25 为转发和消息保留付费

消息转发实际上花费了一些 Gas（取决于转发的消息大小），因此该分片链的验证人会从消息中扣除 Gas 费。 即使该消息由于超立方体路由而被多次转发，转发费也通常远小于当消息最终传递给其接收者时所支付的 Gas 费。 此外，只要消息保存在某个分片链的输出队列中，它就是分片链全局状态的一部分，因此长时间保存的全局数据费用也会被收集起来要求支付。

### 2.4.26 发送至主链和来自主链的消息

消息可以直接从任何分片链发送到主链，反之亦然。 但是，在主链中发送消息和处理消息的 Gas 价格非常高，因此只有在真正需要时才会使用此功能 - 例如，验证人需要存入他们股权的时候。 在某些情况下，发送到主链消息的最小价值是被预定义的，仅当消息被接收方视为“有效”时才会退回。

消息无法通过主链自动路由。workchain_id̸ ≠ -1 的消息（-1是表示主链的特殊 workchain_id）无法传递给主链。

原则上，可以在主链内创建消息转发智能合约，但使用它的价格会较高。

### 2.4.27 同一个分片链中帐户之间的消息

在某些情况下，由某个分片链的帐户生成的消息发往同一个分片中的另一个帐户。 例如，这发生在一个尚未拆分为多个分片的新工作链中。

此类消息可能会累积在分片链的输出队列中，然后作为后续块中的传入消息进行处理（为此目的，任何分片都被视为其自身的邻居）。 但是，在大多数情况下，可以在原始块本身内传递这些消息。

为了实现这一点，分发到相同账户的消息就会被局部排序，并且对分片块中包括的所有交易进行这样的局部排序。 特别地，允许一个交易的输出消息优先于更早的交易被处理。

在这种情况下，消息体不会被复制两次。 相反，原始的和正在被处理的交易引用的是相同的消息。

## 2.5 全局分片状态

现在我们准备描述 TON 区块链的全局状态，或者至少是基本工作链的分片状态。

我们从包括全局分片链状态的“高级”或“逻辑”开始描述。

### 2.5.1 分片链状态是帐户链状态的集合

根据无限分片范式（参见2.1.2），任何分片链只是一个（临时）虚拟“帐户链”集合，每个账户链只包含一个帐户。 这意味着，本质上，全局分片链状态必须是一个 Hashmap:

> (式23) ShardchainState := (Account -> AccountState)

如果我们正在讨论分片链(w, s)的状态，那么所有出现在这个 Hashmap 索引中的 account_id 必须以前缀 s 开头。

实际上，我们希望将 AccountState 分成几个部分（例如，将帐户输出消息队列分开以简化其相邻分片链的验证），并在 ShardchainState 内部设置若干个哈希映射 (Account-> AccountStateParti)。 我们还可以向 ShardchainState 添加少量“全局”或“必要”参数（例如，属于该分片的所有帐户的总余额，或所有输出队列中的消息总数）。

然而，从“逻辑”（“高级”）的角度来看，(式23) 至少看起来是分片链全局状态的良好近似。 AccountState 和 ShardchainState 的形式描述可以借助 TL Scheme（参见2.2.5）完成。

### 2.5.2 拆分和合并分片状态

请注意，无限分片范例描述显示了在分割或合并分片时应如何处理此状态 (式23) 。 实际上，使用哈希映射，这些状态转换将变得非常简单。

### 2.5.3 账户链状态

（虚拟的）帐户链状态只是一个帐户的状态，由 AccountState 类型描述。 通常它具有 2.3.20 中列出的全部或部分字段，但具体取决于所使用的构造函数。

### 2.5.4 全局工作链状态

与（式23）类似，我们可以通过相同的公式定义全局工作链状态，但允许 account_id 是任何值，而不仅仅是属于一个分片的值。 类似于 2.5.1 中的注释也适用于这种情况：我们可能将此 Hashmap 拆分为几个 Hashmap，也可能添加一些“必要”参数，例如总余额。

本质上，全局工作链状态必须由 ShardchainState 作为分片链状态给出，因为工作链的状态是所有现有的分片合并为一个所得到的状态。

### 2.5.5 低级视角：“单元集合”

帐户链或分片链状态的“低级”描述也是对上面给出的“高级”描述的补充。 这个描述非常重要，因为为网络，存储，序列化和传输几乎所有 TON 区块链使用的数据提供了通用基础（块，分片状态，智能合约存储，Merkle 证明等）。 同时，这种普遍的“低级”描述一旦被理解和实施，就可以使我们只关注“高级”视角。

回想一下，TVM 通过 TVM 单元树或简称单元（参见2.3.14和2.2.5）表示任意代数类型的值（例如，包括 (式23) 的 ShardchainState）。

任何这样的单元由两个描述符字节组成，定义了某些标志和值，原始字节数(0 ≤ b ≤ 128)，和对其他单元的引用数量 (0 ≤ c ≤ 4)。

单元的确切格式取决于实现以及单元是位于 RAM，磁盘，网络数据包，块中等等。 一个有用的抽象模型在于想象所有单元都保存在内容可寻址的内存中，单元格的地址等于其（SHA256）哈希。 回想一下，单元的（Merkle）散列是通过用它们的（递归计算的）散列替换对其子单元的引用并对生成的字节串进行散列来精确计算的。

以这种方式，如果我们使用单元哈希值来引用单元就能让系统稍微简化，并且单元哈希值的起始值与表示它的字节串的哈希值一致。

现在我们看到 TVM 表示的任何对象，包括全局分片状态，都可以表示为“一袋单元”，即一组单元以及对这组单元的一个“根”引用（例如，通过哈希）。 请注意，此描述中删除了重复的单元（“一袋单元”是一组单元，而不是多个单元集合），因此抽象树实际上可以被表示为有向无环图（DAG）。

甚至可能将这种状态以 B- 或 B+ Tree 的形式保存在磁盘上，其包含所有相关通过哈希索引的单元（可能带有一些额外的数据，如子树高度或参考计数器）。 然而，这种天真想法的实现将导致一个智能合约的状态分散在本地磁盘文件和远端文件中，这是我们需要避免的。

现在我们将详细解释 TON 区块链的几乎所有对象如何表示为“单元袋”，从而证明了这种方法的普遍性。

### 2.5.6 区块就是“单元袋”

区块本身可以用代数类型描述，并存储为“单元袋”。 然后，可以简单地通过以任意顺序连接表示“单元袋”中的每个单元的字节串来获得区块的朴素二进制表示。 例如，通过在块的开头提供所有单元的偏移列表，并且尽可能用该列表中的 32 位索引替换成其它单元的引用。 然而，人们应该想象一个区块本质上是一个“单元袋”，所有其它技术细节都只是次要的。

### 2.5.7 将对象作为“单元袋”更新

想象一下，我们有一个表示为“单元袋”的某个旧版本对象，现在我们想要一个代表相同对象的新版本。 方法可能只是将新状态表示为具有其自身根的另一个“单元袋”，并从中移除旧版本中出现的所有单元。则剩下的“单元袋”本质上是对象的更新。再将两个单元联合起来，然后删除旧的根（如果引用计数器变为零，则减少其引用计数器并取消分配单元），那么拥有此对象的旧版本和更新版的每个人都可以计算出新版本。

### 2.5.8 更新帐户状态

特别是，可以使用2.5.7中描述的思想来表示对帐户状态或分片链的全局状态或任何散列映射更新。 这意味着当我们收到一个新的区块（这是一个“单元袋”）时，我们不仅仅是单独处理这个“单元袋”，而是将它首先与代表前一状态的“单元袋”结合起来。在这个意义上，每个区块都可以“包含”区块链的整个状态。

### 2.5.9 更新区块

回想一下，区块本身就是一个“单元袋”，因此，如果需要编辑一个块，就可以类似地将“块更新”定义为“单元袋”，“单元袋”这是该块的先前版本，以便进行如上所描述的处理。这大致是 2.1.17 中讨论的“垂直块”背后的想法。

### 2.5.10 Merkle 证明作为“单元袋”

请注意，（广义）Merkle 证明 - 例如，一个断言 x[i] = y 从已知值 Hash(x) = h（参见2.3.10和2.3.15）开始 - 也可以表示为一袋“单元”。 也就是说，只需要提供一个单元的子集，该子集对应于从 x: Hashmap(n, X) 的根到其所需叶子的路径，其索引为 i: 2n，值为 y: X。如果这些单元的子节点的引用不在这个路径中，将由单元哈希的方式保留为“未解决”。 同时 Merkle 证明也可以通过在“单元袋”中位于从根部的两条路径的并集上的单元来提供，例如 x[i] = y 和 x[i'] = y'， x 对应于索引 i 和 i' 的叶子。

### 2.5.11 Merkle 证明作为来自全节点的查询响应

实质上，具有分片链（或帐户链）状态的完整副本的全节点可以在轻节点（例如，运行 TON 区块链客户端的轻型版本的网络节点）请求时提供 Merkle 证明，从而允许查询者在没有外部帮助的情况下，仅使用此 Merkle 证明中提供的单元执行一些简单的查询。轻节点可以将序列化的查询发送到全节点，并通过 Merkle 证明接收正确响应。 这个 Merkle 证明只包含一个只属于那些分片链状态单元的“单元袋”。 这种方法尤其适用于执行智能合约的“GET 查询”（参见4.3.12）。

### 2.5.12 使用 Merkle 有效性证明进行扩充更新或状态更新

回想一下（参见2.5.7）我们可以通过“更新”来描述对象状态从旧值 x: X 到新值 x': X 的变化。步骤是假定接收者具有旧值 x 及其所有单元的副本，用包含位于表示新值 x' 的子树中的那些单元，但不包含表示旧值 x 的子树中的单元的“单元袋” ，再将两个单元联合起来，然后删除旧的根。

但是，如果接收者没有 x 的完整副本，只知道它的（Merkle）散列 h = Hash(x)，它将无法检查更新的有效性。 但我们希望得到“可验证的”更新，并通过 Merkle 证明旧状态中所有被引用的单元存在，然后任何只知道 h = Hash(x) 的人都能够检查更新的有效性并能够自己计算新的 h' = Hash(x')。

因为我们的 Merkle 证明本身就是“单元袋”（参见2.5.10），所以可以通过“单元袋”构造为扩充更新，这个“单元袋”包含 x 的旧根，以及通过 x 连接的一些子节点，和新的 x' 的根节点和不属于 x 的所有子节点。

### 2.5.13 分片区块中的帐户状态更新

特别是，应该扩充如 2.5.12 所述分片区块中的帐户状态。 否则，有人可能会提交一个包含无效状态（引用了旧状态的缺失单元）更新的块; 如何证明这种无效性成为了一个挑战。

现在，如果块中包含的所有状态更新都得到了扩充，则很容易检查它们的有效性，并且它们的无效性也很容易违反（广义）Merkle 哈希的递归定义。

### 2.5.14 “一切都是单元袋”哲学

上诉表明，我们需要在 TON 区块链或网络中存储或传输的所有内容都可以表示为“一袋单元”。 这是 TON 区块链设计理念的重要组成部分。 一旦理解了“单元袋”并定义了“单元袋”的一些“低级”序列化，就可以在高层次的抽象上简单地定义所有内容（块格式，分片和帐户状态，数据类型等）。

“一切都是一袋单元”的统一理念大大简化了看似无关的服务的实现; 如 5.1.9 中涉及的支付通道。

### 2.5.15 TON Blockchain 的区块头

通常，区块链中的块以块头开始，其包含前一个块的哈希，其创建时间，块中包含的所有交易的树的 Merkle 散列，等等。然后将该头的哈希定义为块的哈希。因为块头最终取决于块中包含的所有数据，所以不能在不改变其散列的情况下改变块。

在 TON 区块链块使用的“单元袋”方法中，没有指定的块头。相反，块哈希被定义为块的根单元的（Merkle）哈希。 因此，块的顶部（根）单元可能被认为是该块的“头”。

但是，根单元可能不包含（通常区块头中）预期的所有数据。 实质上，*Block* 类型中定义的一些字段才会在头中包含。 通常，包括根在内的这些字段将被包含在几个单元中，它们共同构成“Merkle 证明”的单元。有人可能会在任何其他单元之前就包含这些字段，然后，只需要下载块的前几个字节，以获得所有“头单元”。

## 2.6 创建和验证新块

TON 区块链最终由分片块和主链块组成。 必须通过网络创建、验证这些块并将其传播给所有相关方，以使系统平稳正确地运行。

### 2.6.1 验证人

新块由指定的特殊节点（称为人）创建和验证。 基本上，任何节点都可以成为验证人节点，只要它能够将足够大的股权（TON 代币，即 Grams; 参见附录A）存入主链。 验证人将从新生成的块、存储和手续费中获得工作“奖励”，即反映了整个社区对它的“感激”。 该收入按比例分配给所有参与的验证人，以保持 TON 区块链的正常工作。

然而，验证人是一项高度负责任的工作。如果验证人签署了无效区块，则可以通过损失部分或全部股权来处罚，并暂时或永久地从验证人中踢除。如果验证人不参与创建块，则它不会收到与该块相关的奖励份额。 如果验证者人长期放弃创建新块，它可能会丢失部分股份，并被暂停或永久排除在验证人之外。

所有这一切都意味着验证人不会“无所事事”地获得金钱。 实际上，它必须跟踪所有或一些分片链的状态（每个验证人负责验证和创建分片链的某个子集中的新块），执行这些分片链中智能合约的计算，接收有关其它分片链的更新等。此活动需要相当大的磁盘空间，计算能力和网络带宽。

### 2.6.2 验证人而不是矿工

回想一下，TON 区块链使用的是 Proof-of-Stake 方法，而不是当前版的本比特币和以太坊以及大多数其它加密货币采用的 Proof-of-Work 证明方法。 这意味着人们不能“挖掘”新的块获得一些新的代币。 相反，必须成为验证者并花费个人的计算资源来存储和处理 TON 区块链请求和数据。 简而言之，一个人必须是验证者才能开采新的代币。 在这方面，验证人就是新的矿工。

然而，除了作为验证者之外，还有其他一些获得收入的方法。

### 2.6.3 提名者和“矿池”

要成为验证人，通常需要购买和安装多个高性能服务器并为他们提供良好的 Internet 连接。 所以这并不像目前开发比特币所需的 ASIC 设备那么昂贵。 然而，几乎不可能在家用电脑上挖掘出新的 TON 代币，更不用说智能手机了。

在比特币，以太坊和其他工作证明的加密货币挖掘社区中，有一个矿池的概念。矿池中有许多节点，但不具有足以自行挖掘新块的计算能力，矿池中的节点结合其力挖掘新块，并在之后共享奖励。

利益证明世界中的相应概念是提名者的概念。 从本质上讲，这是一个节点借钱来帮助验证人增加其股份; 验证人然后将其奖励的相应份额（或之前商定的一部分 - 比如50％）分配给提名者。

通过这种方式，提名者也可以参与“采矿”并为此目的存入与其意愿成比例的金额而获取一些奖励。 它仅获得验证人奖励的相应份额的一小部分，因为它仅提供“资本”，而不需要购买计算力，存储和网络带宽。

但是，如果验证人因无效行为而失去其股份，则提名人也会失去其股份。 从这个意义上说，提名者分担风险。 它必须明智地选择其指定的验证人，否则可能会赔钱。 从这个意义上说，提名者做出加权决定，并用他们的资金对某些验证人进行“投票”。

另一方面，这个提名或借出系统允许人们能够成为验证者，而无需先投入大量 Grams 资金（TON币）。 换句话说，它可以防止那些使用大量的 Grams 供应的人垄断验证人。

### 2.6.4 渔夫 (Fishermen): 通过指出别人的错误来获取回报

获得一些奖励另一种方法是成为一名渔夫 (Fishermen)。 基本上，任何节点都可以通过在主链中存入少量存款而成为渔夫。 然后它可以使用特殊的主链交易来发布由验证人先前签名和发布的一些（通常是分片链）块的无效（Merkle）证明。 如果其他验证人同意此无效证明，则违规验证人将受到处罚（丢失部分股份），并且渔夫将获得一些奖励（来自从违规验证人处没收的一小部分代币）。 之后，必须按照 2.1.17 中的描述更正无效（分片链）块。 纠正无效的主链块可能涉及在先前提交的主链块之上创建“垂直”块（参见2.1.17），因而没有必要创建主链的分叉。

通常，渔夫是一些分片链的完整节点，并通过运行一些智能合约代码来消耗计算资源。虽然渔夫不需要具有作为验证人的计算能力，但我们认为渔夫是处理新区块的潜在验证者的自然候选人，但尚未被选为验证者（例如，由于未能存放足够大的股权）。

### 2.6.5 整理人: 通过向验证者补充数据来获取回报

另一种获得一些奖励的方法是成为一名整理人。它向验证人准备并建议新的候选分片块，补充（整理）从该分片链和其他（通常是相邻的）分片链的状态和数据，以及合适的 Merkle 证明（例如，当某些消息需要从相邻的分片链转发时）。然后验证人可以轻松地检查建议的候选块的有效性，而无需下载此或其它分片链的完整状态。

因为验证人需要提交新的（整理的）候选区块以获得一些奖励，所以将一部分奖励支付给提供合适候选区块的整理人是有意义的。 通过这种方式，验证人可以通过将其外包给整理者来摆脱观察相邻碎片链状态的必要性。

但是，我们希望在系统的初始部署阶段不会有单独的指定整理人，因为所有验证人都可以自己充当整理人。

### 2.6.6 整理人或验证人: 通过收集用户交易获取回报

用户可以向一些整理人或验证人支付少量代币打开微支付通道，从而在分片链中包含他们的交易。

### 2.6.7 全局验证人选举

通常提前 1 一个月就已经普遍知晓下个月要选出一组“全局”验证人（实际上，每 2^19 个主链块）。

为了成为验证人，节点必须将一些TON代币（Grams）转移到主链中，然后将它们作为股权 s 发送给特殊的智能合约。 与股权一起发送的另一个参数是 *l ≥ 1*，该节点愿意接受的最大验证负载。 l 上还有一个全局上界（另一个可配置参数） *L*，等于10。

然后，通过这个智能合约选择全局验证人，仅仅选择最大股权的 T 位候选人并公布他们的身份。 最初，验证人的总数是 T = 100; 我们预计随着负载的增加它会增长到 1000，它是一个可配置的参数（参见2.1.21）。

每个验证人的实际利益计算如下: 如果最高 T 提议的股权是 s<sub>1</sub> ≥ s<sub>2</sub> ≥···≥ s<sub>T</sub>，则第 i 个验证人的实际股权设置为 s'<sub>i</sub> := min（s<sub>i</sub>, l<sub>i</sub> · s<sub>T</sub>）。 这样，s'<sub>i</sub> / s'<sub>T</sub> ≤ l<sub>i</sub>，因此第 i 个验证人的负载不超过最弱验证人负载的 l ≤ L 倍（因为负载最终与股权成比例）。

然后当选的验证人可以撤回其未使用的部分，即 s<sub>i</sub> - s'<sub>i</sub>。 为竞选上的的候选验证人可以撤回他们所有的股权。

每个验证人都要公开其公共签名密钥，这不一定等同于股份帐户的公钥。

直到验证人任职期结束，验证人的股份会被一直冻结，并且如果出现新的争议（即，发现这些验证人之一签署了无效区块），则会延长一个月。 在此之后，将返还股权，以及验证人的”挖矿“所得和在此期间处理的交易费用。

### 2.6.8 验证人“任务组”选举

整个全局验证人集合（其中每个验证人被认为具有等于其股权的多重性 - 否则验证人可能倾向于假设几个身份并将其中的利益分开）仅用于验证新的主链块。 分片块仅通过特殊选择的验证人子集进行验证，这些验证人子集取自 2.6.7 中所述选择的全局证人集。

为每个分片定义的这些验证人“子集”或“任务组”每小时轮换一次（实际上，每 2^10 个主链块），并且它们是提前一小时知道的，这样每个验证人都知道哪些分片需要验证，以为此做好准备（例如，通过下载丢失的分片链数据）。

用于为每个分片 (w, s) 选择验证人任务组的算法是确定性伪随机的。 它使用验证人嵌入的伪随机数到每个主链块（由使用阈值签名的共识生成）来创建随机种子，然后每个验证器计算 *Hash(code(w). code(s).validator_id.rand_seed)*。 然后验证器按此散列值进行排序，并选择前几个验证器，以便至少具有验证人总股权的 *20/T*，并且至少包含5个验证人。

这种选择可以通过特殊的智能合约来完成。 在这种情况下，选择算法很容易升级，而不需要 2.1.21 中提到的投票机制的硬分叉。 到目前为止提到的所有其他“常数”（例如 2^19, 2^10, T, 20 和 5）也是可配置参数。

### 2.6.9 在每个任务组上轮换优先级顺序

根据前一个主链块和（分片链）块序列号的散列，对分片任务组的成员施加了某个“优先级”顺序。 如上所述，通过生成和排序一些散列来确定该顺序。

当需要生成新的分片块时，选择创建此块的分片任务组验证人通常是此轮换“优先级”顺序的第一个。 如果它无法创建块，则第二个或第三个验证人可以执行此操作。 从本质上讲，他们都可以提议他们的块候选者，但具有最高优先级的验证人建议的候选者应该作为拜占庭容错（BFT）共识协议的结果而产生。

### 2.6.10 候选分片块的传播

由于分片链任务组成员资格是提前一小时知道的，因此他们的成员可以利用 TON 网络的一般机制（参见3.3）构建专用的“分片验证人多播覆盖网络”。当需要生成新的分片块时（通常在最近的主链块传播后一两秒钟），每个人都知道谁具有最高优先级来生成下一个块（参见2.6.9）。该验证人将自行（或者在整理人的帮助下）创建一个新的候选块。验证人必须检查（验证）此块候选（特别是如果它已由某个整理人准备）并使用其私钥对其进行签名。然后使用预先安排的多播覆盖网络将候选块传播到任务组的其余部分（任务组创建其自己的专用覆盖网络，如3.3中所述，然后使用3.3.15中描述的流式多播协议来传播候选块）。

真正的 BFT 方式是使用拜占庭组播协议，例如 Honey Badger BFT 中使用的协议：用 *(N, 2N/3)*-erasure code 编码块候选，直接发送结果数据的 *1/N* 给组的每个成员，并期望它们将其部分数据直接组播到组里所有其他成员。

然而，更快更直接的方法（参见3.3.15）是将候选块分成一系列有符号的千字节块("chunks")，用Reed-Solomon 或 Fountain Code 来增加它们的序列。 并开始向“多播网格”（即覆盖网络）中的邻节点发送块，以期望它们进一步传播这些块。 一旦验证人获得足够的数据能重建候选块，它就签署确认并通过其邻居将其传播到整个组。 然后它的邻节点停止向它发送新的数据，但是可以继续发送这些块的（原始）签名，以让其它节点可以通过自己应用 Reed-Solomon 或 Fountain Code（具有所有必要的数据）来生成后续块，并签名将它们结合起来，并传播给尚未准备好的邻节点。

如果在删除所有“坏”节点后“多播网格”（覆盖网络）继续保持连接（回想一下，以拜占庭方式允许多达三分之一的节点是“坏”的），该算法将继续尽可能快地传播候选块。

不仅指定的高优先级块创建人可以将其候选块多播到整个组，第二和第三优先级的验证人也可以立即在未能从最高优先级验证人接收到候选块之后开始多播它们的候选块。 但是，通常只有具有最大优先级的候选块将由所有（实际上，至少为任务组的三分之二）验证人签名并作为新的分片块提交。

### 2.6.11 验证候选块

一旦验证人接收到候选块并且检查了其原始验证人的签名，则接收验证人通过执行其中的所有交易并检查它们的结果是否与所声明的一致来检查该候选块的有效性。 从其它区块链导入的所有消息必须由合适的 Merkle 证明支持，否则候选块被视为无效（并且，如果将此证明提交给主链，则已经签署了此候选块的验证人可能会受到惩罚）。另一方面，如果发现候选块有效，则接收验证人对其进行签名，并直接通过“多播网络”或网络消息将其签名传播到该组中的其它验证人。

我们想强调 *一个验证人不需要访问这个或相邻的分片链的状态，以便检查（整理的）候选块的有效性。* 这样可以非常快速地进行验证（无需磁盘访问），并减轻验证人的计算和存储负担（特别是，如果他们愿意接受外部整理人的服务来创建候选块）。

### 2.6.12 选举下一个候选块

一旦候选块通过了至少三分之二验证人的有效性签名，它就有资格被提交成为下一个分片块。 一种 BFT 协议会对所选择的候选块（可能存在多于一个）进行共识，所有“好”验证人优选该轮的具有最高优先级的候选块。 作为运行该协议的结果，该块将通过至少三分之二的验证人的签名。 这些签名不仅证明了块的有效性，而且证明了它是由 BFT 协议选出的。 之后，块（没有整理的数据）与这些签名组合，并以确定的方式序列化，最终通过网络传播给所有相关方。

### 2.6.13 验证人必须保留他们签名的块

在验证人加入任务组期间以及之后至少一个小时（或更确切地说是 2^10 个块）之前，验证人应该保留他们签署和提交的块。未能向其他验证人提供签名块可能会受到惩罚。

### 2.6.14 将新分片块的头和签名传播到所有验证人

验证人使用类似于为每个任务组创建的多播网状网络，将新生成的分片块的头和签名传播到全局验证人。

### 2.6.15 生成新的主链块

在生成所有（或几乎所有）新的分片块之后，可以生成新的主链块。 该过程与选举分片块（参见2.6.12）基本相同，不同之处在于所有验证人（或至少三分之二）都必须参与此过程。 因为新的分片块的头部和签名被传播到所有验证人，所以每个分片中最新块的哈希必须包含在新的主链块中。 一旦这些哈希值被提交到主链块中，外部观察者和其他分片链可能会认为新的分片块已提交且不可变（参见2.1.13）。

### 2.6.16 验证人必须保留主链的状态

主链和分片链之间的一个值得注意的区别是，所有验证人都需要跟踪主链状态，而不依赖于整理人的数据。 这很重要，因为验证人任务组的知识来自主链状态。

### 2.6.17 分片块是并行生成和传播的

通常，每个验证人都是几个分片链任务组的成员; 它们的数量大约与验证人的股权成比例。 这意味着验证人并行运行新的分片块生成协议的多个实例。

### 2.6.18 缓解块保留攻击

因为验证人仅在看到块头和签名之后才将新的分片块的哈希值插入到主链中，所以生成此块的验证人很可能会合谋并试图避免完整地发布新块。 这将导致相邻分片链的验证人无法创建新块，因为它们必须至少知道新块的输出消息队列，才将其哈希值提交到主链中。

为了缓解这种情况，新块必须收集来自其他验证人的签名（例如，相邻分片链的任务组的三分之二联合签名），证明这些验证人确实具有该块的副本并且愿意将它们发送给其它验证人（如有需要）。 只有具备了这些签名，新块的散列才能包含在主链中。

### 2.6.19 主链块比分片块更晚生成

主链块大约每五秒生成一次，分片块也是如此。 然而，虽然所有分片链中新块的产生基本上是同时的（通常由新的主链块的生成而触发），但是我们故意延迟新的主链块生成，以允许在主链块中包含新的分片块哈希值。

### 2.6.20 较慢验证人的奖励可能会较低

如果验证人运行速度较慢，则可能无法验证新的候选块，并且无法包含在新块所需的三分之二签名的验证人中。在这种情况下，它将获得与此块奖励的较低份额。

这激励验证人提供更强的硬件，更快的软件和更快的网络连接，以便尽可能快地处理用户交易。

但是，如果验证人在提交之前未能对块进行签名，则其签名可能包含在下一个块中，然后包含在块中的部分奖励（但会指数级减少，具体取决于生成的块数）仍然会被给予此验证器。

### 2.6.21 验证人签名的“深度”

通常，当验证人签署块时，签名仅证明块的相对有效性：如果此块和其他分片链中的所有先前块都有效，则此块有效。 验证人会因将前一个块中提交的无效数据视为理所当然而受到惩罚。

但是，块的验证人签名具有称为“深度”的整数参数。 如果它不为零，则意味着验证人也断言指定数量的父块的（相对）有效性。 这也是“慢”或“临时离线”验证人捕获并签署一些未经签名的块的方法，然后仍然会给他们一些块奖励（参见2.6.20）。

### 2.6.22 验证人负责分片块签名的相对有效性; 以及绝对有效性

我们想再次强调，在分片块 B 上的验证人签名仅证明该块的相对有效性（或者如果签名具有“深度” d，则可能也是先前 d 个父块的相对有效性，参见2.6.21）。 换句话说，验证人断言通过应用 2.2.6 中描述的块评估函数*ev_block*，从先前状态 s 获得了分片链的下一个状态 s':

> (式24) s′ = ev_block(B)(s)

以这种方式，如果原始状态 s 证明是“不正确的”（例如，由于父块的无效），则不能惩罚签名块 B 的验证人。渔夫（参见2.6.4）只有在发现相对无效的区块时才应该向验证人汇报。 因此 PoS 系统作为一个整体，努力使每个块相对有效，而不是递归（或绝对）有效。但是请注意，如果区块链中的所有区块都相对有效，那么所有区块和整个区块链都是绝对有效的; 使用区块链长度的数学归纳可以很容易地表示这个陈述。 通过这种方式，验证块的相对有效性的断言一起证明了整个区块链的绝对有效性。

注意，通过对块 B 进行签名，验证人在给定原始状态 s 的情况下能断言该块是有效的。 以这种方式，验证人必须对在（式24）的评估期间执行对原始状态的单元最小检查。

例如，假设预期包含从提交到块中的交易帐户的原始余额的单元具有 0 个原始字节而不是预期的 8 或 16。然后原始余额无法从单元恢复，并在尝试处理块时发生“未处理的异常”。 在这种情况下，验证人不应该在签署这样的块上受到痛苦的惩罚。

### 2.6.23 签署主链块

主链块的情况有所不同：通过签署主链块，验证人不仅断言该块的相对有效性，还断言直到该验证人承担其责任时的第一个块的所有前面的块的相对有效性。

### 2.6.24 验证人的总数

在目前为止所描述的系统中，验证人总数的上限T（参见2.6.7）不能超过几百或上千，因为所有验证人都应该用 BFT 共识协议创建每个新的主链块，但不清楚这些协议是否可以扩展到数千个参与者。更重要的是，主链块必须收集所有验证人中至少三分之二的签名，并且这些签名必须包含在新块中（否则，系统中的所有其他节点都没有理由信任新块而不自己验证它）。如果超过，例如，每个主链块中必须包含上千个验证人的签名，这将意味着由所有全节点存储并通过网络传播的每个主链块中有更多数据，并且需花费更多的处理能力来检查这些签名（在 PoS 系统中，全节点不需要自己验证块，但是他们需要检查验证人的签名）。

虽然限制 T 到一千个验证人似乎对 TON 区块链部署的第一阶段来说已经足够了，但是当分片链的总数变得如此之大以至于几百个验证人不足以处理时，所以现在就必须为未来的增长做出准备。 为此，我们引入了一个额外的可配置参数 *T' ≤ T*（最初等于T），并且只有最优的 T' 个被选举的验证人（按股权）才能创建和签署新的主链块。

### 2.6.25 系统的去中心化

人们可能怀疑 TON 区块链等 PoS 系统依赖于 T≈1000 验证人来创建所有分片和主链区块。与传统的工作证明区块链相比，这必然会变得“过于集中”。 比如， Bitcoin 或 Ethereum，原则上每个人都可以挖掘一个新区块，而没有明确的矿工总数上限。

然而，流行的 Proof-of-Work 区块链，如比特币和以太网，目前需要大量的算力（高“哈希率”）来挖掘新块。因此，新区块的开采往往集中在几个超级玩家手中，他们在自己的数据中心里投入大量资金，这些数据中心装满了针对挖矿优化的定制硬件; 并且算力也集中在几个大型矿池的手中，这些矿池集中并协调了那些无法自己提供足够“哈希率”的人群。

因此，截至2017年，超过75％的以太坊或比特币区块由不到10名矿工生产。 事实上，两个最大的以太坊采矿池共同产生了超过一半的新区块！ 显然，这样的系统比依赖于 T≈1000 个节点来生成新块的系统更加集中。

人们可能还会注意到成为 TON 区块链验证人所需的投资，即购买硬件（例如，几台高性能服务器）和股份比成为一个成功的独立比特币或以太坊矿工所需的要低得多。 实际上，2.6.7 的参数 *L* 将迫使提名者不加入最大的“矿池”（即，已经积累了最大股份的验证人），而是寻找目前接受来自提名者资金的较小验证人， 或者甚至创建新的验证人，因为这将允许更高比例的验证人，并且还可以使用提名者的股份，从而获得更大的回报。 通过这种方式，TON Proof-of-Stake 系统实际上鼓励分散（创建和使用更多验证人）并惩罚集中化。

### 2.6.26 块的相对可靠性

块的（相对）可靠性仅是签署此块的所有验证人的总股权。 换句话说，如果这个区块被证明无效，某些验证人就会失去它的股权。如果交易的转移价值低于块可靠性，就可以认为足够安全。从这个意义上讲，相对可靠性是外部观察者在特定区块中可以拥有的信任度。

请注意，我们说的是块的相对可靠性，其前提是父块和所有其所指的分片块都有效（参见 2.6.22）。

块的相对可靠性在提交后可以逐渐变得更可靠（例如，当添加了迟来的验证人签名时，参见 2.6.21）。 另一方面，如果这些验证人中的一个由于其与其它相关块的不当行为而失去其部分或全部股份，则块的相对可靠性可能降低。

### 2.6.27 “强化”区块链

重要的是，为验证人提供激励以尽可能地提高块的相对可靠性。 实现此目的的一种方法是向验证人分配一小笔奖励，从而让它们为其它分片块签名。 即使是“潜在”的验证人 —— 他们已经存入了不足以通过被纳入全局验证人集（参见2.6.7）的股份，也可能参与此活动（如果他们同意冻结股份，而不是在选举失败后撤回它）。这些潜在的验证人可能会成为渔夫：检查某些区块的有效性，以报告无效区块并获得相关的奖励。

### 2.6.28 块的递归可靠性

还可以将块的递归可靠性定义为其相对可靠性的最小值以及它所引用的所有块的递归可靠性（即，主链块，先前的分片块和相邻的分片链的一些块）。 换句话说，如果该块被证明是无效的，或者因为它本身无效或者因为它所依赖的块之一是无效的，那么至少某个验证人会丢失一定数量的收益。如果真的不确定是否信任某个块中的特定交易，则应该计算该块的递归可靠性，而不仅仅是块的相对可靠性。

在计算递归可靠性时走得太远是没有意义的，因为如果我们看得太远，我们将看到由验证人签署的块的股权已经解冻并撤回。在任何情况下，我们都不允许验证人考虑引用那些太旧的块（即，如果使用当前的可配置参数值，则是在两个月前创建的块），并创建从它们开始的分叉或使用“垂直区块链”（参见2.1.17）的手段纠正它们，即使它们是无效的块。我们假设两个月的时间段为检测和报告任何无效块提供了充足的机会，因此如果在此期间没有对块进行质询，则根本不可能受到质疑。

### 2.6.29 轻节点的 Proof-of-Stake

TON 区块链使用的 Proof-of-Stake 方法的一个重要结果是，TON 区块链的轻节点不需要下载所有分片块甚至主链块的块头，以能够自行检查由全节点提供给它的 Merkle 证明的有效性。

实际上，因为最新的分片块哈希包含在主链块中，所以全节点可以容易地提供 Merkle 证明，即从主链块开始到给定分片块的有效哈希。接下来，轻节点只需要知道主链的第一个块，将其（或至少其中的散列）内置到客户端软件中，并且大约每个月重复此过程。这样，它可以仅查询几个最新的主链块，使用它们作为检查由全整节点提供的 Merkle 证明基础。

## 2.7 分片链的拆分和合并

TON 区块链最具特色和独特的功能之一是它能够在负载变得过高时自动将分片链分成两部分，并在负载降低时将它们合并（参见2.1.10）。我们必须详细讨论它，因为它的独特性及其对整个项目的可扩展性至关重要。

### 2.7.1 分片配置

回想一下，在任何给定的时刻，每个工作链被分成一个或几个分片链 (w, s)（参见2.1.8）。

这些分片链可以由二叉树的叶节点表示，具有根 (w, ∅)，并且每个非叶节点 (w, s) 具有子节点 (w, s.0) 和 (w, s.1)。 通过这种方式，属于工作链 w 的每个帐户都被分配给一个分片链，并且知道当前分片链配置的每个人都可以确定 account_id 被包含在分片 (w, s)中: 这个分片也仅仅是二进制字符串 s 为前缀的account_id 所在的分片。

分片配置（即此分片二叉树，或给定 w 的所有活动分片 (w, s) 的集合），是主链状态的一部分，并且每个人都可用于跟踪主链状态。 

### 2.7.2 最近的分片配置和状态

回想一下，最新的分片块的哈希值包含在每个主链块中。 这些哈希值以分片二叉树（实际上是树的集合）组织。 这样，每个主链块都包含最新的分片配置。

### 2.7.3 宣布并执行分片配置中的更改

可以通过两种方式更改分片配置：分片 (w, s) 可以分为两个分片 (w, s.0) 和 (w, s.1)，或两个“兄弟”分片 (w, s.0) 和 (w, s.1) 可以合并为一个分片 (w, s)。

这些拆分/合并操作被预先通知分为几个（例如，2^6，这是可配置参数）块，首先通知在相应的分片块的“块头”，然后通知引用这些分片块的主链块。 所有相关方都需要被预先通知以为计划的改变做出准备（例如，构建覆盖多播网络以分发新创建的分片链的新块，如 3.3 中所讨论的），然后提交更改。首先更改分片块，然后传播到主链块。 通过这种方式，主链块不仅定义了创建之前的最新分片配置，还定义了下一个立即分片配置。

### 2.7.4 新分片的验证人任务组

回想一下，每个分片（即每个分片链）通常分配一个验证人子集（验证人任务组），专门用于创建和验证相应分片链中的新块（参见2.6.8）。 这些任务组在提前一段时间内知道自己（大约一小时）被选出，并且在此期间是不可变的。

但是，由于拆分/合并操作，实际的分片配置可能会在此期间发生更改。 必须将任务组分配给新创建的分片。 做法如下：

请注意，任何活动分片 (w, s) 都将是某些唯一确定的原始分片 (w, s') 的后代，这意味着 s' 是 s 的前缀，或者它将是原始分片的子树的根 (w, s') ，其中 s 将是每个 s' 的前缀。 在第一种情况下，我们只需将原始分片 (w, s') 的任务组加倍作为新分片 (w, s)的任务组。 在后一种情况下，新分片 (w, s) 的任务组将是所有原始分片 (w, s') 的任务组的并集。

通过这种方式，每个活动分片 (w, s) 都被分配了一个明确定义的验证人子集（任务组）。 拆分分片时，两个子代都从原始分片继承整个任务组。 合并两个分片时，它们的任务组也会合并。

跟踪主链状态的任何人都可以为每个活动分片计算验证人任务组。

### 2.7.5 在原始任务组的任职期间拆分/合并的限制

最终，新的分片配置将会生效，并且将自动为每个分片分配新的专用验证人子集（任务组）。 在此之前，必须对拆分/合并操作施加一定的限制; 否则，如果原始分片快速分成 2<sup>k</sup> 个新分片，则原始任务组可能因 k 过大而终结。

这是通过从原始分片配置（用于当前负责的验证人任务组的配置）中删除距离限制的活动分片配置来实现的。例如，如果 s' 是 s 的前身，则可能要求分片树中从活动分片 (w, s) 到原始分片 (w, s') 的距离不得超过3。 如果 s' 是 s 的后继（即 s 是 s' 的前缀），则距离不得超过2。 否则，不允许拆分或合并操作。

粗略地说，人们在给定的验证人任务组的责任期间对拆分或合并的次数施加限制。除此之外，在通过合并或拆分创建了一个分片之后，它不能在一段时间（一定数量的块）内重新配置。

### 2.7.6 确定拆分的必要性

分片链的拆分操作由某些条件触发（例如，如果连续 64 个块，其中至少 90％ 的链都是满负载）。这些条件由分片链的任务组监视。如果条件满足，首先在新的分片块的头部中包含“拆分准备”标志，并且传播到引用该分片块的主链块。 然后，在几个块之后，“拆分提交”标志被包含在分片块的头部中，并传播到下一个主链块。

### 2.7.7 执行拆分

在分片 (w, s) 的块 B 中包含“拆分提交”标志之后，该分片中不会有后续块 B'。 相反，将分别创建分片 (w, s.0) 和 (w, s.1) 的两个块 B0' 和 B1'，两者都将块 B 引用为它们的前一个块（并且它们都将块头中的分片标记为已被分割）。下一个主链块将包含新分片块 B0' 和 B1' 的哈希值。

请注意，两个新的分片链的验证人任务组与拆分前的验证人相同，因此它们将自动获得其状态副本。 从无限分片范式的角度来看，状态拆分操作本身非常简单（参见2.5.2）。

### 2.7.8 确定合并的必要性

通过某些条件检测到分片合并的必要性（例如，对于 64 个连续块，两个兄弟分片块的大小之和不超过最大块大小的 60％）。 这些条件还应考虑这些区块所消耗的燃料费，并将其与当前区块燃料限制进行比较，否则有一些计算密集型交易会阻止区块包含更多交易从而导致区块可能会很小。

这些条件由兄弟分片 (w, s.0) 和 (w, s.1) 的验证人任务组监控。 请注意，兄弟块必须是超立方体路由的邻居（参见2.4.19），这样来自任意分片的验证人任务组都能在某种程度上监控兄弟分片。

当满足这些条件时，任何一个验证人子组都可以通过发送特殊消息建议它们进行合并。 然后，它们组合成一个临时的“合并任务组”运行 BFT 一致性算法，并在必要时传播块的更新和候选块。

如果他们就合并的必要性和准备情况达成共识，则“合并准备”标志将被提交到每个分片链的某些块的块头中，以及准备好兄弟任务组的至少三分之二的验证人的签名，并传播到下一个主链块，以便每个人都可以为即将进行的重新配置做好准备。 但是，它们在一段时间内还需继续在单独的分片中创建新块。

### 2.7.9 执行合并

之后，当来自两个原始任务组的验证人并集准备好成为合并的分片链的验证人时（这可能涉及兄弟分片的状态合并和状态转移），它们提交“合并提交”标志到块的块头中（此事件将传播到下一个主链块），并停止在单独的分片中创建新块（一旦出现合并提交标志，则禁止在单独的分片中创建块）。相反，创建一个合并的分片块（由两个原始任务组的并集），在其“块头”中引用它的两个“父分片块”。 这将会反映在 *包含新创建的合并分片块* 的下一个主链块中。 之后，合并的任务组继续在合并的分片链中创建块。

## 2.8 区块链项目的分类

我们通过将 TON 区块链与现有的区块链项目进行比较来结束对 TON 区块链的简要讨论。 然而，在此之前，我们必须引入区块链项目的一般分类。2.9 节将会对这些区块链项目进行比较。

### 2.8.1 区块链项目的分类

作为第一步，我们提出区块链的一些分类标准。 这些分类都有些不完整和肤浅，因为忽略了项目的一些具体和独特的特征。但是，我们认为这是区分区块链项目的必要一步。

我们考虑的标准清单如下：

1. 单链与(Signle-blockchain)多链架构(Multi-blockchain)
2. 共识算法：PoS 与 PoW
3. 对于 Proof-of-Stake 系统，块的生成与精确验证和一致性算法（两个主要是 DPoS 与BFT; 参见2.8.4）
4. 支持图灵完备的智能合约（参见2.8.6）

多区块链系统有额外的分类标准（参见2.8.7）：

1. 区块链的类型和规则：同质(homogeneous)，异质(heterogeneous)（参见2.8.8），混合(Mixed)（参见2.8.9），联邦制(Confederations)（参见2.8.10）
2. 是否存在内部或外部的主链（参见2.8.11）
3. 原生支持分片（参见2.8.12）; 静态或动态分片（参见2.8.13）
4. 区块链之间的相互交互：松耦合和紧耦合系统（参见2.8.14）

### 2.8.2 单链与多链项目

第一个分类标准是系统中区块链的数量。 最古老，最简单的项目包括一个区块链（简称“单链项目”）; 更复杂的项目使用（或者更确切地说，计划使用）多个区块链（简称“多链项目”）。

单链项目通常更简单，更易测试，也经受住了时间的考验。 它们的主要缺点是性能低，对于通用系统而言，其处于 10 TPS（比特币）到少于 100 TPS（以太坊）的水平。 一些专门的系统（如Bitshares）每秒能够处理成千上万的专用交易，代价是要求区块链状态放在内存中，并将处理限制在预定义的特殊交易集中，然后由高度优化的代码执行，这些代码用 C++ 这样的语言编写（这里没有VM）。

多链项目承诺了用户渴望的可扩展性。它们可以支持更大全局状态和每秒更多的交易，代价是项目更加复杂，并且其实现更具挑战性。 因此，市面上几乎没有多链项目，但大多数提议中的项目都是多项目，并且我们相信未来属于多链项目。

### 2.8.3 块的创建和验证：Proof-of-Work vs. Proof-of-Stake

另一个重要的区别是用于创建和传播新块的算法和协议，它们的有效性检查，并且如果分叉，又该如何选择哪条链。

两种最常见的范例是工作证明（PoW）和权益证明（PoS）。工作证明通常允许任何节点创建（“挖掘”）新块，如果它足够幸运地解决了一个无用的计算问题，那么它将获得与新块相关的一些奖励。 在分叉的情况下（例如，如果两个节点同时发布两个有效块，但有不同的父块），则最长的分叉链获胜。通过这种方式，区块链不可变性的保证是基于生成区块链所花费的工作量（计算资源）：任何想要创建区块链分叉的人都需要重新做这项工作来创建已提交块的替代版本。 为此，如果要控制创建新块那么就要所需花费的算力要占总计算能力的50％以上，否则分叉将没有几乎成为主链。

Proof-of-Stake 基于一些由大量股权（加密货币）背书的特殊节点（验证人）来声明他们已经检查（验证）了一些块并且认为它们是有效的。验证人对块进行签名，并为此获得一些奖励; 但是，如果一个验证人被抓到签署了一个不正确的区块，并且证据确凿，那么其部分或全部股权将被没收。通过这种方式，区块链的有效性和不变性的保证由验证人对区块链有效性所投入的总股权计量。

Proof-of-Stake 方法更加自然，它激励验证人（取代 PoW 矿工）执行有用的计算（检查或创建新的块，特别是执行所有交易代码）而不是计算无用的哈希。 通过这种方式，验证人将购买更适合于处理用户交易的硬件，以挣取与这些交易相关的奖励，从整个系统的角度来看，这是非常有用的投资。

然而，PoS 在实现方面更具挑战性，因为必须考虑到许多罕见但可能发生的问题。 例如，一些恶意验证人可能合谋破坏系统以获取利润（例如，通过改变它们自己的加密货币余额）。 这导致了一些理论问题。

简而言之，Proof-of-Stake 更自然，更有前途，特别是对于多链项目（因为如果有许多区块链，工作量证明需要大量的计算资源），但必须要更仔细地思考和实现。 大多数目前正在运行的区块链项目，尤其是最老的项目（比如比特币和至少原来的以太坊），都使用了 PoW 证明。

### 2.8.4 PoS 的变种， DPoS 与 BFT

虽然 Proof-of-Work 算法彼此非常相似，并且主要区别在于计算新块的哈希函数，但是 Proof-of-Stake 算法有更多可能性，这值得对它们进行细分。

基本上，必须回答以下关于 Proof-of-Stake 算法的证明问题：

1. 谁可以生产（“挖掘”）一个新的块 - 任何全节点，或只是一个（相对）小验证人子集的成员？（大多数PoS系统需要生成新块，并由多个指定验证人之一签名。）
2. 验证人是否保证通过其签名的块的有效性，或者是否所有全节点都可以自行验证所有块？ （可扩展的 PoS 系统必须依赖验证人签名，而不是要求所有节点验证所有区块链的所有块。）
3. 是否预先知道下一个区块的指定生产者，以便其他人无法替换该块？
4. 新创建的块最初只由一个验证人（其生产者）签名，还是必须从一开始就收集大部分的验证人签名？

虽然根据这些问题的答案，似乎有 2^4 种可能的 PoS 算法，但实际上的区别归结为两种主要的 PoS 方法。 实际上，设计用于可扩展多链系统的大多数现代 PoS 算法以相同的方式回答前两个问题：只有验证人才能生成新块，并且它们保证块的有效性，而不需要所有全节点检查有效性。

至于最后两个问题，他们的答案与具体项目高度相关，基本上只有两个基本选项：

Delegated Proof-of-Stake (DPOS): 每个区块都有一个众所周知的指定生产者; 没有人可以产生那个块;新块最初只由其生成的验证人签名。

拜占庭容错（BFT）PoS 算法：有一个已知的验证人子集，其中任何一个都可以提议一个新块; 产生若干个候选块必须由大多数验证人验证和签名，在被释放到其他节点之前是通过拜占庭容错共识协议来实现选择的。

### 2.8.5 DPoS 和 BFT PoS 的比较

BFT 的优点在于，新生产的块从一开始就具有大多数验证人的签名证明其有效性。 另一个优点是，如果大多数验证人正确执行 BFT 共识协议，则根本不会出现任何分支。另一方面，BFT 算法往往相当复杂，需要更多时间让验证人子集达成共识，因此，不能经常生成块。 这就是为什么我们期望 TON 区块链（从这个分类的角度来看TON 是一个BFT项目）每五秒只产生一次块。 在实践中，这个间隔可能会减少到2-3秒（尽管我们不承诺这一点），但如果验证人遍布全球，则不会变得更快。

DPoS 算法具有非常简单和直接的优点。它可以经常产生新的块 - 比方说，每两秒一次，或者甚至每秒一次，因为它依赖于事先已知的指定块生产者。

但是，DPoS 要求所有节点（或至少所有验证人）验证收到的所有块，因为生成和签署新块的验证人不仅确认了该块的相对有效性，而且还确认了它所引用的前一个块的有效性，并且回溯主链的所有块的有效性（可能直到当前验证人子集的任职期的开始）。在当前验证人子集上存在预定顺序，因此对于每个块，存在指定的生成人（即，期望生成该块的验证人）; 这些指定的生产者以循环方式轮换。通过这种方式，块首先仅由其生成验证人签名; 然后，当下一个区块被开采时，它的生产者选择引用这个区块而不是它的前任之一（否则它的区块将位于较短的链中，这可能会在“最长的分叉”竞争中失利），下一个块的签名本质上也是前一个块的附加签名。通过这种方式，新块逐渐收集更多验证人的签名 - 例如，在生成接下来的 20 个块所需的时间内收集 20 个签名。一个全节点要么等待这二十个签名，要么自己验证块，从一个充分确认的块（比如二十个块）开始，这可能不是那么容易。

DPoS 算法的明显缺点是，只有在开采了20多个块之后，新块（以及提交到其中的交易）才能达到相同的信任级别（2.6.28 中讨论的”可靠性“）。 BFT 算法，可立即提供此级别的信任（例如，20 多个签名）。另一个缺点是，DPoS 使用“最长分叉”方法切换到其他分叉; 如果一些生产者在我们感兴趣的生产者之后未能生成后续的块（或者由于网络分区或复杂的攻击让我们未能观察到这些块），这就很可能产生分歧。

我们认为 BFT 虽然比 DPoS 实现更复杂，需要更长的时间间隔才能生成块，但这更适合于“紧耦合”（参见2.8.14）的多链系统。因为其它链可以立即在新的块中看到一个已完成的事务（例如，为它们生成一条消息），而不等待20次有效性确认，也不需要等待接下来的六个块确保没有分叉出现并自行验证有效性（在可扩展的多链系统中验证其他区块链的块可能代价过高）。因此，BFT 可以实现可扩展性，并同时保持高可靠性和可用性（参见2.8.12）。

另一方面，DPoS可能是“松耦合”多链系统的理想选择（不需要区块链之间的快速交互） - 例如，如果每个区块链（“工作链”）代表一个单独的分布式交易所，区块链间的交互仅限于将代币从一个工作链转移到另一个工作链上（或者更确切地说，以一个接近 1:1 的汇率将一个代币交易到另一个工作链中）。这是在 BitShares 项目中实现的，它非常成功地使用了 DPoS。

总而言之，虽然 DPoS 可以生成新的块并且更快地打包交易（块之间的间隔更小），但这些交易达到了在其他区块链和离线应用程序中使用它们所需的信任级别比 BFT 系统慢得多 - 比如说，确认交易需要 30 秒而不是 5 秒。 但更快的交易打包并不意味着更快的交易确认。如果需要快速的区块链间交互，这可能会成为一个巨大的问题。 在这种情况下，必须放弃 DPoS 而选择 BFT PoS。

### 2.8.6 支持图灵完备的智能合约

区块中的交易通常会改变区块链状态（例如，将一些加密货币从一个账户转移到另一个账户）。一些区块链项目可能只允许某些特定的预定义类型交易（例如，提供了正确的签名的前提下从一个帐户到另一个帐户的价值转移）。其它区块链项目可能会在交易中支持某种有限形式的脚本。最后，一些区块链项目支持在交易中执行任意复杂的代码，只要系统的性能允许，能使系统（至少在原理上）能够支持任意应用程序。这通常称为“图灵完备的虚拟机和脚本语言”（意味着可以重写任何计算机语言编写的程序以在区块链内执行）和“智能合约”（驻留在区块链中的程序）。

当然，对任意智能合约的支持使系统真正具有灵活性。 另一方面，这种灵活性需要付出代价：这些智能合约的代码必须在某个虚拟机上执行，并且当有人想要创建或验证块时，必须为块中的每个交易都执行此操作。与预定义且不可变的简单交易类型集相比，这会降低系统的性能，但这可以通过使用诸如 C++（而不是某些虚拟机）之类的语言来实现以优化它们的处理速度。

最终，对图灵完备智能合约的支持似乎在任何通用区块链项目中都是可取的; 否则，区块链项目的设计者必须事先决定他们的区块链将用于哪些应用程序。事实上，比特币区块链中缺乏对智能合约的支持是必须创建新区块链项目以太坊的主要原因。

在（异构; 参见2.8.8）多链系统中，通过在一些区块链（即工作链）中支持图灵完备的智能合约，以及一小部分预定义的高度优化的交易类型，可以让系统拥有“两全其美”的效果。

### 2.8.7 多链系统的分类

到目前为止，该分类对于单链和多链系统都是有效的。 然而，多链系统有更多的分类标准，反映了系统中不同区块链之间的关系，我们现在讨论这些标准。

### 2.8.8 区块链类型：同质和异质系统

在多链系统中，所有区块链基本上可以是相同类型并且具有相同的规则（即，使用相同格式的交易，用于执行智能合约代码的相同虚拟机，使用相同的加密货币，等等），区块链之间的规格都是相同的，而只有链与链之间的交易数据不同，在这种情况下，我们说系统是同质(homogeneous)的。 否则，不同的区块链（通常称为工作链）可以有不同的“规则”，我们说这样的系统是异质(heterogeneous)的。

### 2.8.9 混合系统

一个混合系统，其中有几组不同的类型或规则，但是也存在许多具有相同规则。据我们所知，TON 区块链是这种系统的唯一例子。

### 2.8.10 异质的区块链具有相同的规则，联邦制

在一些情况下，具有相同规则的若干区块链（工作链）可以存在于异质系统中，但是它们之间的交互与具有不同规则的区块链之间的相互作用相同（即，它们的相似性未被明确利用）。 即使看上去它们使用“相同的”货币，实际上他们使用的是不同的“代币”。有时人们甚至可以使用某些机制将这些代币转换为接近 1：1 的汇率。然而，在我们看来，这并不能使系统同质化; 它仍然是异质的。我们说这种具有相同规则的异质工作链集合是联邦制(Confederations)。

虽然用相同规则（即联盟）创建多个工作链的异构系统看起来似乎是构建可扩展系统的廉价方式，但这种方法也有许多缺点。从本质上讲，如果有人在许多具有相同规则的工作链中托管大型项目，她实际上并不会获得大型项目，而是获得该项目的许多小实例。 这就像拥有一个聊天应用程序（或游戏），允许在任何聊天（或游戏）房间中最多有 50 个成员，但通过创建新房间来“扩展”以在必要时容纳更多用户，这样的系统是真正可扩展的吗？

### 2.8.11 存在外部或内部主链

有时，多链项目有一个独特的“主链”（有时称为“控制链”(Control blockchain)），例如，用于存储系统的整体配置，当前的验证人集合（用于 PoS 系统）等等。 有时其它链被“束缚”在主链上，例如通过将最新块的哈希值加入到主链中（这也是 TON 区块链所做的事情）。

在某些情况下，主链是外部的，这意味着它不是项目的一部分，而是其他预先存在的链，最初与新项目完全无关，并且是未定的。 例如，可以尝试使用以太坊区块链作为外部项目的主链，并为此目的将特殊智能合约发布到以太坊区块链中（例如，用于选择和惩罚验证人）。

### 2.8.12 支持分片

一些区块链项目（或系统）本身支持分片，这意味着几个区块链（必然是同质的; 参见2.8.8）被认为是单个（从高级别的角度来看）虚拟区块链的分片。 例如，可以创建具有相同规则的 256 个分片链(shardchains)，并根据其 account_id 的第一个字节将帐户的状态保存在一个选定的分片中。

分片是扩展区块链系统的一种自然方法，因为如果它被正确实现，那么系统中的用户和智能合约根本不需要知道分片链的存在。 实际上，当系统负载变得太高时，人们通常希望为现有的单链项目（例如以太坊）添加分片。

另一种扩展方法是使用 2.8.10 中描述的“联邦制”异质区块链，它允许每个用户将她的帐户保存在一个或多个工作链中，并将资金从她的帐户转移到另一个工作链中，基本上以 1:1 的汇率交换。这种方法的缺点已在 2.8.10 中讨论过。

然而，分片在快速可靠的系统中并不那么容易实现，因为它暗示了不同分片链之间的大量消息。 例如，如果一个账户均匀分配在 N 个分片中，并且交易是从一个账户到另一个账户的简单资金转账，那么在单个区块链中只会执行所有交易的一小部分 (1/N); 几乎所有 (1 - 1/N) 的交易都涉及需要频繁通讯的两条链。如果我们希望这些交易能被快速地处理，那么我们就需要一个快速的消息分发系统在分片之间传输消息。换句话说，区块链项目需要在 2.8.14 中描述的意义上“紧耦合”。

### 2.8.13 动态和静态分片

分片可能是动态的（在必要时自动创建其他分片）也或是静态的（预定义数量的分片，只能通过硬分叉进行更改）。 大多数支持分片的区块链系统都是静态的; TON 区块链使用动态分片（参见2.7）。

### 2.8.14 链与链间的交互：松耦合和紧耦合系统

可以根据组成区块链间的交互级别对多链系统进行分类。

最低级别的支持是不同链之间没有任何交互。我们在这里不考虑这种情况，因为我们认为这些链不是一个区块链系统的一部分，而只是相同区块链协议的单独实例。

下一级是原则上链与链间的消息传递成为可能，但没有任何具体支持。我们称这是“松耦合”系统; 在它们中的一方必须发送消息才能在区块链之间传递价值，就好像它们是完全属于独立的区块链项目一样（例如，比特币和以太坊; 想象两方想要将比特币区块链中的一些比特币转换为以太币，并保存在以太坊区块链中）。换句话说，必须在原区块链的块中包含出站消息（或其生成交易），然后，她（或其他一方）必须等待足够的确认才能将原始交易视为“已提交”和“不可变”，这样才能够执行外部操作。只有这样，才能将消息中继到目标区块链（可能需要引用 Merkle 证明原始交易的存在）。

如果在传输消息之前没有等待足够长的时间，或者由于其他原因发生了分叉，则两个区块链的状态将变得不一致：交易被传递到被废弃的第 1 条区块链中，而最终选择的分叉却不包含那笔交易。

有时通过标准化消息的格式，以及所有工作链的块中的输入和输出消息队列，来添加对消息传递的部分支持（这在异构系统中尤其有用）。 虽然这在一定程度上促进了消息传递，但它在概念上与上面的情况并没有太大的不同，因此这种系统仍然“松耦合”。

相比之下，“紧耦合”系统包含特殊机制以在所有区块链间提供快速的消息传递，以期望能够在原始链的块中生成的消息会立即被传递到另一个工作链中。另一方面，“紧耦合”系统也能在分叉的情况下保持整体一致性。虽然这两个要求乍一看似乎是矛盾的，但我们认为 TON 区块链使用的机制（将分片块哈希包含在主链块中; 使用“纵向”区块链来修复无效块，参见2.1.17; 超立方路由，参见2.4.19; 即时超立方路由，参见2.4.20）能使其成为“紧耦合”系统，也许这是目前唯一的“紧耦合”系统。

当然，构建“松耦合”系统要简单得多; 然而，快速高效的分片（参见2.8.12）要求系统是“紧耦合”的。

