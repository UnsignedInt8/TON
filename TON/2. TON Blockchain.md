# 2. TON Blockchain

我们将从叙述 TON 的核心组件 —— TON Blockchain 开始。叙述的方法是“自上而下”：我们首先给出整体的一般描述，然后提供每个组件的更多细节。

尽管原则上该区块链协议的若干个实例可以独立运行（例如，由于硬叉），为简单起见，我们在这里谈论 TON 区块链时只考虑其中一个。

## 2.1 TON Blockchain 是二维区块链

TON Blockchain 是区块链的集合（甚至是区块链集合的集合），因为没有一个单链区块链项目有能力满足百万级TPS的目标，而不是现在标准的每秒数十个交易。

### 2.1.1 区块链类型

该区块链是以下区块链的集合:

1. 主链(Masterchain): 包含协议和当前参数值的一般信息，认证者及其权益信息，工作链(Workchains)以及分片信息，以及最重要的最近工作链和分片链(Shardchains)的区块 Hash 集合。

2. 工作链(Working blockchains, Workchains): 作为“主力”的工作链最多有 2^32 个，它们包含了交易和只能合约。不同的工作链可能有不同的“规则”，这意味着它们拥有不同的账号地址格式、不同的交易格式、不同的智能合约虚拟机、不同的基础货币等等。然而，它们必须满足某些基本的互操作性标准，才能是不同的工作链之间的交互成为可能并且相对简单。在这方面，TON 区块链是异质(heterogeneous)的，类似于 EOS 和 PolkaDot 项目。

3. 分片链(Shardchains): 每一条工作链最多可以分成 2^60 个分片链。它们具有和工作链相同的规则和区块格式，但本身只负责一个账户子集。换句话说，系统中内置了一种分片形式。 因为所有这些分片链共享一个共同的块格式和规则，所以 TON 区块链在这方面是同质(homogeneous)的，类似于以太坊扩展提议中讨论的内容。

4. 在分片链中的每一个区块事实上并不是区块，而是一条链。通常块区块链或纵向区块链的区块里只包含一个块，然后我们会认为这对应分片链中的一个区块（这种情况下我们称之为“横向区块链”）。但是，如果需要修复不正确的分片链，则需要向纵向区块链中提交一个新的区块，这其中包含无效的横向区块链的块的替换，或者仅包含需要更改此块的先前版本的那些部分的描述。这是一种用于替换检测到的无效块的 TON 特定机制，而不会让分片链分叉，2.1.17将会对此有详细描述。现在，我们仅仅认为每个分片链不是传统的区块链，而将其认为是区块链的区块链或二维区块链。

### 2.1.2 无限分片范式

几乎全部的区块链的分片提议都是“自上而下”的: 首先想象有一条链，然后讨论如何将其拆分成几个交互的分片链，以提高性能并实现可扩展性。

TON 的分片方法是“自下而上”的，解释如下。

想象一下，将分片发挥到极致，那么每一条分片链中只保留一个账户或智能合约。这样我们就会有大量的“账户链”，每个账户链描述一个账户的状态和状态转换，并相互发送消息以传输价值和信息。

当然，拥有数亿条区块链是不切实际的，其中每个区块链通常很少出现更新（即新区块）。 为了更有效地实现它们，我们将这些“帐户链”分组为“分片链”，以便分片链的每个块本质上是已分配给此分片的帐户链块的集合。 因此，“帐户链”在“分片链”中仅具有纯粹的虚拟或逻辑存在。

我们将这种观点称为**无限分片范式**，它解释了 TON 区块链的许多设计决策。

### 2.1.3 消息、即时超立方路由

无限分片范式告诉我们将每个帐户（或智能合约）视为自己的分片链。 那么一个帐户可能影响另一个帐户状态的唯一方法就是向它发送一条消息（这是所谓的 Actor 模型的特殊实例，帐户为 Actors）。 因此，一个不同账户之间的消息系统（因为源账户和目标帐户通常位于不同的分片链中）对于可扩展系统（如TON区块链）至关重要。 实际上，TON 区块链的一个新功能，称为即时超立方路由，使其能够将在一个分片链块中创建的消息传递和处理到目标分片链的下一个块中，而不管系统中分片链的总数。

### 2.1.4 主链、工作链与分片链的数量

TON 区块链只包含一个主链。 但是，该系统最多可以容纳 2^32 个工作链，每个工作链最多可分为 2^60 个分片链。

### 2.1.5 工作链通常是虚拟的链，而不是真实的链

因为工作链通常被细分为分片链，所以工作链的存在是“虚拟的”，这意味着它不是真正的链，而是在下面2.2.1中描述的一般定义——只是一组分片链。 当只有一个分片链对应一个工作链时，这个独特的分片链可以认为是工作链，在这种情况下，工作链至少在一段时间内成为“真正的”区块链，从而获得与传统的单区块链设计的表面相似性。 然而，无限分片范式告诉我们，这种相似性确实是肤浅的: 潜在的大量“账户链”可以暂时归为一条区块链（分片链）仅仅只是一个巧合。

### 2.1.6 工作链的ID

每个工作链由其编号或由一个无符号的32位整数（workchain_id：uint32）标识。 工作链由主链中的特殊交易创建，该交易用于定义（以前未使用的）工作链标识符和工作链的正式描述，以使该工作链与其他工作链可交互以及可对该工作链的块进行验证。

### 2.1.7 工作链的创建与激活

只需准备好支付发布新工作链规范所需的（高）主链交易费用，基本上任何社区成员都可以创建新的工作链。 但是，为了激活新的工作链，需要三分之二的验证人共识，因为他们需要升级他们的软件来处理新工作链的块，并表示它们已经准备好通过特殊的主链交易使新的工作链生效。 对激活新工作链感兴趣的一方可能会通过智能合约分发的一些奖励来为验证人提供一些激励，以便支持新的工作链。

### 2.1.8 分片链的ID

每条分片链由一对元组 (w, s) = (workchain_id，shard_prefix) 标识，其中 workchain_id: uint32 标识相应的工作链，shard_prefix: 2^(0...60) 是一个长度最多为 60 的位串，定义了这个分片链负责的帐户子集。 即所有具有以 shard_prefix 开头的 account_id 的帐户（也就是说将 shard_prefix 作为最高有效位）将被分配给该分片链。

### 2.1.9 账户链的ID

回想一下，帐户链只是虚拟的存在。 但是，它们有一个自然的标识符 - 即 (workchain_id，account_id) - 因为任何帐户链都包含有关状态的信息和正好一个帐户（简单帐户或智能合约）的更新。

### 2.1.10 分片链的动态拆分与合并

一个不太复杂的系统可能使用静态分片。例如，通过使用 account_id 的前八位来选择 256 个预定义分片中的一个。

TON 区块链的一个重要特征是它实现了动态分片，这意味着分片数量是不固定的。相反，如果满足某些条件，则分片 (w，s) 可以自动细分为分片 (w，s.0) 和 (w，s.1)（比如很长一段时间内，原始分片上的交易负载足够高）。 相反，如果负载在一段时间内保持过低，则分片 (w，s.0) 和 (w，s.1) 可以自动合并回 shard (w，s) 。

因此，最初只为 工作链w 创建了一个分片 (w，∅)。 之后如果有必要，它会细分为更多的分片（参见2.7.6和2.7.8）。

### 2.1.11 基本工作链 (Basic Workchain/Workchain Zero)

虽然可以使用特定的规则和交易定义多达 2^32 个工作链，但我们最初只定义了一个工作链，其 workchain_id = 0。此工作链称为 Workchain Zero 或基本工作链，它用于处理 TON 智能合约和转移 TON 代币（也称为 **Gram**，参见附录A）。大多数应用程序可能只需要 Workchain Zero。 基本工作链的分片链将被称为 Basic Shardchains。

### 2.1.12 块生成时间

我们期望在每个分片链和主链中大约每五秒生成一个新块。 这是相当小的交易确认时间。 所有分片链的新块几乎同时生成，并且大约在分片链的新快生成一秒后又生成一个新的主链块，这是因为主链必须包含所有分片链的最新块的哈希值。

### 2.1.13 主链使工作链与分片链紧耦合

一旦分片链块的 Hash 被合并到主链的块中，那么该分片链块及其所有父块就被认为是“规范的”，这意味着它们可以被所有分片链的后续块中引用为固定不变的东西。 实际上，每个新的分片链块也包含最新主链块的 Hash，并且从该主链块引用的所有分片链块被更新的块视为不可变的。

本质上，这意味着在分片链块中提交的交易或消息可以安全地用在其它分片链的下一个块中，而不需要等待。（举个反例: 在大多数的“松散耦合”系统中，用户在转发消息或发送交易之前需要 20 个确认，例如EOS。）而 TON 这种在提交后仅仅五秒就能使用其它分片链中的交易和消息的能力就是我们认为的“紧密耦合”系统（这是同类产品中的第一个），这也是我们能够提供前所未有的性能的原因之一（参见2.8。 12和2.8.14）。

### 2.1.14 主链的块 Hash 也是全局状态

根据2.1.13，从外部观察者的角度来看，最后一个主链块的 Hash 就完全确定了系统的整体状态，所以不需要分别监视所有分片链的状态。

### 2.1.15 通过认证者生成新块

TON 区块链使用 Proof-of-Stake(PoS) 在分片链和主链中生成新块。 这意味着有一组特殊节点通过特殊的主链交易存入权益（大量 TON 代币），以便有资格进行新的块生成和验证。

然后，以确定性伪随机方式将较小的验证人子集分配给每个分片 (w，s)，并且大约每 1024 个块改变一次。 这个验证人子集通过从客户端收集合适的交易到新的有效候选块，并就下一个块的内容达成共识。 对于每个块，在验证人上存在伪随机选择的顺序，以确定哪个候选块具有最高的优先级。

验证人和其它节点检查候选块的有效性; 如果验证人签署了无效候选块，则可能会因此被惩罚一部分或全部的权益，或者在一段时间内不能验证区块的有效性。 在此之后，其它验证人应该对下一个区块的选择达成共识（主要是通过BFT（拜占庭容错;参见2.8.4）共识协议的有效变体，类似于 PBFT [4]或 Honey Badger BFT[11]）。 如果达成共识，则创建新块，并且验证人在它们之间划分交易费，以及一些系统奖励的代币。

每个验证人能够参与进多个不同验证人子集中。在这种情况下，全部的验证与共识都是并行计算的。

在所有的分片链的新块生成之后，或者生成区块超时，主链就会生成新的一个包括所有分片链的最新块哈希值的块。这是由所有验证人的 BFT 共识完成的。

有关 TON PoS 及其经济模型的更多详细信息，请参见第2.6节。

### 2.1.16 主链的分叉

由紧耦合引起的复杂性是，在主链切换到不同的分支几乎必然需要在至少一些分片链中切换到另一个分支。 另一方面，只要主链中没有分叉，就不可能在分片链中分叉。

一般规则是，如果主链中的块 B' 是 B 的前身，B' 包含分片链(w, s) 的块 B'<sub>w, s</sub> 的 HASH(B'<sub>w,s</sub>)，并且 B 包含了 HASH(B<sub>w, s</sub>)，那么 B'<sub>w, s</sub> 一定是 B<sub>w, s</sub> 的前身，否则主链块中的 B 是无效的。

我们预计主链轮叉是罕见的，甚至是不存在的。因为在 TON 区块链采用的 BFT 范例中，只有在大多数验人行为不正确（这将意味着违法者将遭受重大的权益损失）的情况下才能发生这种情况（参见2.6.1和2.6.15）。 因此，预计分片链中也没有真正的分叉。 相反，如果检测到无效的分片链块，它将通过二维区块链的“纵向区块链”机制（参见2.1.17）进行纠正，而不会分叉“横向区块链”（即分片链）。 同样的机制也可用于修复主链块中的非致命错误。

### 2.1.17 更正无效的分片链块

通常，在分片链中必须达到三分之二验证人达成拜占庭共识才能提交新块。 但是，系统必须检测先前提交的无效块以及对其更正。

当然，一旦由由验证人或“渔夫”（系统的任何节点进行了某种存款，而提出有关区块有效性的问题）找到无效的分片块，签署无效区块的验证人将因此失去部分权益和/或被禁职（后一种措施对于攻击者窃取其他良性验证人的签名密钥的情况很重要）。

但这还不够，因为系统的整体状态由于先前提交的分片块无效而证明是无效的。必须使用较新的有效版本替换此无效块。

大多数系统都会通过“回滚”到此分片链中的无效块之前的最后一个块并且该块不受从其他每个分片链中传播无效块的消息的影响，并从这些块创建新的分叉来实现此目的。 这种方法的缺点是大量的其他正确的和提交的交易突然回滚，并且不清楚它们是否稍后还能被有效确认。

TON 区块链通过使每个分片链和主链（横向区块链）的每个“块”自身成为一个小区块链（纵向区块链）来解决这个问题，这个纵向区块链包含不同版本的“块”或它们的“差异”。 通常，纵向区块链只包含一个区块，而分片链则看起来像一个经典的区块链。 然而，一旦确认块的无效性并在主链块中得到确认，则在纵向上允许在该无效块被新块替换以纠正该无效块。 新块由相关分片链的当前验证人子集生成。

新“纵向”块的有效规则非常严格。特别是，如果无效块中包含有效的虚拟“帐户链块”（参见2.1.2），则必须由新的块更正且保持账户链不变。

一旦在无效块之上提交了新的“纵向”块，其哈希就会发布在新的主链块中（或者更确切地说是在新的“纵向”块中，位于包含最初发布的无效分片块HASH的主链块上方），并且引用了该无效快的所有分片快都会更正。这是通过在纵向区块链中为以前引用“不正确”区块的所有区块提交新的“纵向”区块来解决的; 新的纵向块将引用最新（已更正）的版本。 同样，也禁止更改未受影响的帐户链（即，接收与先前版本相同的消息）。 通过这种方式，修复不正确的块会产生“涟漪”，最终传播到所有受影响的分片链的最新块; 这些变化也反映在新的“纵向”主链块中。

一旦该“涟漪”到达最新的块，新的分片块就作为最新块版本的后继者生成。这意味着它们将从一开始就包含对正确纵向块的引用。

主链状态隐含地定义了将每个“纵向”区块链的第一个块的 HASH 转换为其最新版本的 HASH 的映射。 这使客户端能够通过其第一个（通常是唯一的）块的 HASH 来识别和定位任何纵向区块链。

### 2.1.18 TON 代币与多币工作链

TON 区块链支持多达 2^32 种不同的“加密货币”，由 32 位 currency_id 区分。可通过主链中的特殊交易添加新的加密货币。 每个工作链都有一个基本的加密货币，并且可以有多个额外币种。

有一种特殊的加密货币，currency_id = 0，即 TON 币，也称为 **Gram**（参见附录A）。 它是Workchain Zero 的基本加密货币。它也用于充当手续费和验证人的权益收入。

原则上，其他工作链可能会收取其它代币的交易费用。在这种情况下，应提供一些智能合约，将这些交易费自动转换为 Grams。

### 2.1.19 消息与价值转移

属于相同或不同工作链的分片链可以相互发送消息。 虽然消息的确切形式取决于接收工作链和接收帐户（智能合约），但有一些共同的字段使得工作链之间的消息传递成为可能。 特别地，只要它们被接收工作链声明为可接受的加密货币，那么每个消息可以以一定量的 Gram 和/或其他注册的加密货币的形式附带一些价值。

消息传递的最简单形式是从一个（通常不是智能合约）账户到另一个账户的价值转移。

### 2.1.20 TON 虚拟机

TON虚拟机（也称为 TON VM或 TVM）是用于在主链和基本工作链中执行智能合约代码的虚拟机。 其它工作链可以与 TVM 一起使用别的 TVM。

在这里，我们列出了它的一些功能。 它们将在 2.3.12, 2.3.14 和其它地方进一步讨论。

1. TVM 将所有数据表示为 TVM 单元(cell)的集合（参见2.3.14）。每个单元最多包含 128 个数据字节，4 个对其它单元的引用。 由于“一切都是单元”的理念（参见2.5.14），这使 TVM 能够处理与 TON 区块链相关的所有数据，包括块和区块链全局状态（如有必要）。

2. TVM 可以处理任意代数数据类型的值（2.3.12），其表示为 TVM 单元的树或有向无环图。但是，它并不关心数据类型; 数据类型只适用于单元。

3. TVM 内置了对哈希表(Hashmaps)的支持。

4. TVM 是基于栈的虚拟机。 它的堆栈保持64位整数或单元格引用。

5. 支持 64 位，128 位和 256 位算术。 所有 n 位算术运算有三种形式：无符号整数，有符号整数和 2^n 整数模（后一种情况下不进行自动溢出检查）。

6. TVM 具有从 n 位到 m 位的无符号和有符号整数转换，对于所有 0 ≤ m，n ≤ 256，具有溢出检查。

7. 默认情况下，所有算术运算都执行溢出检查，大大简化了智能合约的开发。

8. TVM 具有 "multiply-then-shift" 和 “shift-then-divide” 算术运算，其中间值以大整数类型计算; 这简化了算术的过程。

9. TVM 支持位串和字符串。

10. 支持预定义的 256 位椭圆曲线加密（ECC），包括Curve25519。

11. 还存在对一些椭圆曲线上的 Weil Pairings 的支持，这对于快速实现zk-SNARK是有用的。

12. 支持流行的哈希函数，包括 SHA256。

13. TVM 支持 Merkle Proofs（参见5.1.9）。

14. TVM 支持“大型”智能合约或“全局”智能合约，而这种智能合约必须要有分片的意识（参见2.3.18和2.3.16）。 通常（本地）智能合约可以是无需考虑分片的。

15. TVM 支持闭包。

16. 可以在TVM内轻松实现“spineless tagless G-machine”。

除了“TVM 汇编语言”之外，还可以为 TVM 设计几种高级语言。 所有这些语言都将具有静态类型，并将支持代数数据类型。 我们设想了以下可能性：

1. 一种类似Java的命令式语言，每个智能合约类似于一个单独的类。

2. 一种惰性函数式语言（类似 Haskell）。

3. 一种快速的函数式语言（类似 ML）。

### 2.1.21 可配置参数

TON 区块链的一个重要特征是它的许多参数都是可配置的。 这意味着它们是主链状态的一部分，并且可以通过主链中的某些特殊提议/投票/结果交易进行更改，而无需任何硬叉。 改变这些参数将需要三分之二的验证人投票和所有其它支持该修改提议的一半以上参与者投票。

## 2.2 TON 区块链的一般概括

### 2.2.1 区块链的一般定义

通常，区块链是一系列首尾相连的块，每个块 B 包含前一个块(blk-prev [B])的引用 （通常通过将前一个块的 HASH 包含在当前块的头部中），以及交易清单。 每个交易描述了全局区块链状态的一些转换; 按顺序将块中的每个交易以某个算法计算，即可获得该块的最新状态。

### 2.2.2 TON 区块链的相关性

回想一下，TON Blockchain 不是传统意义的区块链，而是二维区块链的集合（即区块链的区块链;参见2.1.1），因此上述内容并不直接适用于 TON Blockchain。 但是，我们从传统区块链的这些一般性开始，将其用于构造更复杂结构的系统。

### 2.2.3 区块链实例和区块链类型

人们经常使用区块链这个词来表示一般的区块链类型及其特定的区块链实例。 例如，2.2.1 指的区块链实例。

以这种方式，区块链类型通常是块的列表（即，有限序列）的块(Block<sup>\*</sup>)类型的“子类型”，由满足某些兼容性和有效性条件的那些块序列组成：

> (式1) Blockchain ⊂ Block<sup>\*</sup> 

定义区块链的更好方法是将区块链看作是依赖的耦合类型，由耦合（B，v）组成，第一个组件 B: Block<sup>\*</sup> 是 Block<sup>\*</sup>  列的类型，以及 第二部分 v: isValidBc（B）是B的有效性的证明或见证。如下：

> (式2) Blockchain ≡ Σ<sub>(B:Block<sup>\*</sup>)</sub>*isValidBc*(B)

我们在这里使用从引用[16]的类型依赖和表示法。

### 2.2.4 依赖类型论， Coq 和 TL

请注意，我们在这里使用（Martin-Löf）依赖类型论，类似于在 [Coq](https://coq.inria.fr) 中使用的理论。

依赖类型论的简化版本也用在TL ([Type Language](https://core.telegram.org/mtproto/TL)) ，其将用于 TON 区块链的正式规范中以描述所有数据结构的序列化以及块，交易等的设计。

实际上，依赖类型论给出了证明是什么的有用形式化，例如，当需要为某些块提供无效证明时，这种形式证明（或它们的序列化）可能变得很方便。

### 2.2.5 类型语言 (TL)

由于 TL（类型语言）用于TON 区块、交易和网络数据报的正式规范，因此需要进行简短的讨论。

TL 是一种适用于从属代数类型描述的语言，允许使用数值和类型参数。 通过几个构造函数描述每种类型。 每个构造函数都有一个可读的标识符和一个名称。 除此之外，构造函数的定义包含字段列表及其类型。

构造函数和类型定义的集合称为 TL Scheme。 它通常保存在一个或多个带有后缀 .tl 的文件中。

TL Scheme 的一个重要特征是它确定了一种明确的方式来序列化和反序列化代数类型的值（或对象）。 也就是说，当需要将值序列化为字节流时，首先序列化用于此值的构造函数的名称。之后递归地序列化每个字段。

适用于将任意对象序列化为32位整数序列的 TL 的先前版本的描述可在 https://core.telegram.org/mtproto/TL 获得。 一种名为 TL-B 的 TL 新版本也正在开发，其用于描述 TON 项目的对象序列化。 这个新版本可以将对象序列化为字节流甚至比特流（不仅仅是32位整数），并且支持序列化到 TVM 单元树中（参见2.3.14）。 TL-B 的将是 TON 区块链的正式规范的一部分。

### 2.2.6 区块和交易是状态转换运算符

通常，任何区块链都具有关联的全局状态和交易。 区块链的语义在很大程度上取决于事务函数：

> (式3) *ev_trans′* : Transaction × State → State<sup>\?</sup>

X<sup>\?</sup> 代表 MAYBE X，即把 MAYBE 应用单子 X 的结果。本质上，类型 X<sup>\?</sup> 的值是类型 X 的值或特殊值 ⊥ （表示缺少实际值）。在我们的例子中，我们使用 State<sup>\?</sup> 而不是State 作为结果类型，这是因为如果从某些原始状态调用交易可能是无效的（比如试图从账户中提取比实际存在的更多的钱）。

我们可能更倾向于柯理化的方式表达：

> (式4) *ev_trans* : Transaction → State → State<sup>\?</sup>

因为区块本质上是一个交易列表，所以可以从 *ev_trans* 导出区块评估函数：

> (式5) *ev_block* : Block → State → State<sup>\?</sup>

它表示一个块 B:Block 和前一个区块链状态 s:State（可能包括前一个块的哈希值）并计算下一个区块链状态 `s'= ev_block(B)(s)`，其计算结果可能是 True 或为特殊值⊥（表示无法计算下一个状态。即，如果从给定的起始状态进行计算，则该区块无效 - 例如，该块包括试图从空账户中扣款的交易。）。

### 2.2.7 区块序列号

区块链中的每个块 B 可以通过其序列号 BLK-SEQNO(B) 来引用，从第一个块(0)开始，并且每当传递到下一个块时递增1。 

> (式6) BLK-SEQNO(B) = BLK-SEQNO(BLK-PREV(B)) + 1 

请注意，在存在分支时序列号不会唯一地标识块。

### 2.2.8 区块 HASH

引用块 B 的另一种方式是通过其散列 BLK-HASH(B)来引用，其实际上是块 B 头部的散列（然而，块的头部通常依赖于块 B 的所有内容的散列）。 假设所使用的散列函数没有冲突（或者至少它们是非常不可能的），则通过其散列唯一地标识块。


### 2.2.9 计算 HASH

在对区块链算法进行正式分析前，我们假设使用没有冲突的 k 位散列函数 HASH: Bytes<sup>\*</sup>→2<sup>k</sup>:

> (式7) Hash(s) = Hash(s′) ⇒ s = s′  // for any s, s′ ∈ Bytes<sup>\*</sup> 

这里 Bytes = {0...255} = 2^8 是字节类型，或者是所有字节值的集合，Bytes<sup>\*</sup> 是任意（有限）字节列表的类型或集合; 而2 = {0,1} 是比特类型，而 2<sup>k</sup> 是所有 k 比特序列（即，k比特数）的集合。

当然，(式7) 在数学上是不可能的，因为从无限集到有限集的映射不能是单射的。 一个更严格的假设是:

(式8) ∀s, s′ : s ≠ s′, P (Hash(s) = Hash(s′)) = 2<sup>−k</sup>

但是，这对于证明来说并不方便。 对于某些小ε（例如，ε= 10<sup>-18</sup>），只要我们接受失败概率 ε（即，最终结论将是真实的，概率至少为1  - ε），那么如果（式8）在 2<sup>-k</sup>N < ε 的证明中最多使用 N 次，则我们可以推理（式7）为真。

最后结论：为了使（式8）的概率陈述真正严格，必须在所有字节序列（Byte<sup>*</sup>）的设置上引入概率分布。这样做的一种方法是假设所有相同长度的字节序列都是等概率的，并设置观察长度 l 的序列的概率等于p<sup>l</sup> − p<sup>l+1</sup>。然后（式8）应该被理解为当 p 从向于 1 时的条件概率 `P(Hash(s) = Hash(s′)|s ≠ s′)` 的极限。

### 2.2.10 TON 区块链中使用的 HASH

我们暂时使用 SHA256 作为 TON 区块链的哈希算法。 如果无法满足未来需求，那么将来也可以用另一个哈希函数替换它。 散列函数的选择是协议的可配置参数，因此可以在没有硬分叉的情况下进行更改，如2.1.21中所述。

## 2.3 区块链状态，账户和哈希表

我们在上面已经提到，任何区块链都定义了某个全局状态，每个区块和每个交易都定义了这个全局状态的转换。 这里我们描述 TON 区块链使用的全局状态。

### 2.3.1 账户ID

TON 区块链使用的基本帐户ID（至少是主链和 0 号工作链）使用的是 256 位整数，我们假设它是特定椭圆曲线的 256 位公钥。 

(式9) account_id : Account = uint<sub>256</sub> = 2^256

此处 Account 是帐户类型，而 account_id 是帐户类型的特定变量。

其他工作链可以使用其他帐户 ID 格式。 例如，可以使用比特币风格的帐户 ID，也就是 ECC 公钥的 SHA256。

但是，在创建工作链时必须固定帐户 ID 的位长 l，并且它必须至少为64，因为 account_id 的前64位用于分片和消息路由。

### 2.3.2 重要组件 —— 哈希表（哈希映射）

TON 区块链状态的主要组成部分是哈希表。在一些情况下，我们定义“映射” h: 2<sup>n</sub> -> 2<sup>m</sup>。更一般地说，我们可能对复合类型 X 的哈希映射 h: 2<sup>n</sup> -> X 感兴趣。但是，索引类型几乎总是 2<sup>n</sup>。

有时候，我们有一个空“默认值”: X，而哈希表 h: 2<sup>n</sup> -> X 由其“默认值” i → "empty" 初始化。

### 2.3.3 示例: TON 帐户余额

TON 账户余额给出了一个重要的例子。 这是一个哈希映射:

(式10) balance : Account → uint<sub>128</sub>

它表示 Account 的 uint<sub>128</sub> 余额。此哈希映射的默认值为零，这意味着最初（在处理第一个块之前）所有帐户的余额为零。

### 2.3.4 示例：智能合约的持久化存储

另一个例子是智能合约的持久化存储，它可以（非常近似地）表示为哈希映射:

(式11) storage : 2<sup>256</sup> -> 2<sup>256</sup>

此映射也具有默认值零，这意味着未初始化的持久存储单元为零。

### 2.3.5 示例：所有智能合约的持久化存储

因为我们有多个智能合约，分别由 account_id 区分，每个都有独立的持久化存储，因此我们必须有一个哈希表：

(式12) Storage : Account -> (2<sup>256</sup> -> 2<sup>256</sup>)

将智能合约的 account_id 映射到持久化存储中。

### 2.3.6 哈希映射类型

哈希映射不仅仅是一个抽象的（部分定义的）函数 2<sup>n</sup> -> X; 它有一个规范的表示。因此，假设我们有一个特殊的哈希映射类型:

> (式13) Hashmap(n,X) : Type

对应于（部分）数据结构的编码映射 2<sup>n</sup> -> X。我们也可以写

> (式14) Hashmap(n : nat)(X : Type) : Type

或

> (式15) Hashmap : nat → Type → Type

我们总是可以将 h: Hashmap(n, X) 转换为映射 hget(h): 2<sup>n</sup> -> X<sup>\?</sup>。从此以后，我们通常写 h[i] 而不是 hget(h)(i):

(式16) h[i] :≡ hget(h)(i) : X<sup>\?</sup> for any i: 2n, h: Hashmap(n,X)

### 2.3.7 将哈希映射类型定义为 Patricia 树

从逻辑上讲，可以将 Hashmap(n, X) 定义为深度为 n 的（不完整）二叉树，边缘标为 0 和 1，叶节点的值为 X。 描述相同结构的另一种方式是对于长度等于 n 的二进制串（按位）trie。

在实践中，我们更喜欢使用 trie 的紧凑表示，通过压缩每个顶点，使只有一个子节点对应其父节点。 其结果表示称为 Patricia 树或二进制基数树。 现在每个中间顶点都只有两个由非空二进制字符串标记的子节点，左边的子节点为零，右边的子节点为1。

换句话说，Patricia 树中有两种类型的（非根）节点:

1. Leaf(x)，包含 X 类型的值 x。

2. Node(l, s<sub>l</sub>, r, s<sub>r</sub>)，其中 l 引用左子节点或子树，s<sub>l</sub> 是标记连接此顶点到其左子节点的边的位串（始终以0开头），r是右子树，s<sub>r</sub> 是标记连接此顶点到右子节点的位串（总是以1开头）。

第三种类型的节点，仅用于 Patricia 树的根节点：

1. Root(n, s<sub>0</sub>, t)，其中 n 是 Hashmap(n, X) 的索引位串的公共长度，s<sub>0</sub> 是所有索引位串的公共前缀，t 是对 Leaf 或 Node 的引用。

如果我们想让 Patricia 树为空，那么需要使用第四种类型的（根）节点：

1. EmptyRoot(n)，其中n是所有索引位串的公共长度。

我们通过下式定义 Patricia 树的高度：

> (式17) HEIGHT(LEAF(x)) = 0

> (式18) HEIGHT(NODE(l, s<sub>l</sub>, r, s<sub>r</sub>)) = HEIGHT(l) + LEN(s<sub>l</sub>) = HEIGHTt(r) + LEN(s<sub>r</sub>)

> (式19) HEIGHT(Root(n, s<sub>0</sub>, t)) = LEN(s<sub>0</sub>) + HEIGHT(t) = n

最后两个公式中每个公式中的最后两个表达式必须相等。 我们使用高度为 n 的 Patricia 树来表示 Hashmap(n, X) 类型的值。

如果树中有 N 个叶子（即我们的 Hashmap 包含 N 个值），则恰好有 N-1 个中间顶点。 插入新值总是涉及通过在中间插入新顶点并添加新叶作为此新顶点的另一个子节点来分割现有边。 从散列映射中删除值则相反：删除了一个叶子及其父级，并且父级的父级和另一个子级直接链接。

### 2.3.8 Merkle-Patricia 树

使用区块链时，我们希望能够能将它们化减为单个哈希值来比较 Patricia 树（即哈希图）及其子树。Merkle 树给出了实现这一目标的经典方法。 本质上，我们需要借助为二进制字符串定义的散列函数，才能计算对象的散列 Hash(x) x: X 的二进制序列化，而达到我们想要描述一种散列 Hashmap(n, X) 类型的对象 h 的方法。

可以递归地定义 Hash(h)，如下所示：

> (式20) Hash(Leaf(x)) := Hash(x)

> (式21) Hash((l, s<sub>l</sub>, r, s<sub>r</sub>)) := Hash(Hash(l). Hash(r). Code(s<sub>l</sub>). Code(s<sub>r</sub>))

> (式22) Hash(Root(n, s<sub>0</sub>, t)) := Hash(Code(n). Code(s<sub>0</sub>). Hash(t))

这里 s.t 表示（位）字符串 s 和 t 的串联，并且 Code(s) 是所有位串 s 的前缀代码。

稍后我们将看到（参见2.3.12和2.3.14）这是一个（稍微调整过的）递归定义的哈希值，用于任意（从属）代数类型的值。

### 2.3.9 