# 2. TON Blockchain

我们将从叙述 TON 的核心组件 —— TON Blockchain 开始。叙述的方法是“自上而下”：我们首先给出整体的一般描述，然后提供每个组件的更多细节。

尽管原则上该区块链协议的若干个实例可以独立运行（例如，由于硬叉），为简单起见，我们在这里谈论 TON 区块链时只考虑其中一个。

## 2.1 TON Blockchain 是二维区块链

TON Blockchain 是区块链的集合（甚至是区块链集合的集合），因为没有一个单链区块链项目有能力满足百万级TPS的目标，而不是现在标准的每秒数十个交易。

### 2.1.1 区块链类型

该区块链是以下区块链的集合:

1. 主链(Masterchain): 包含协议和当前参数值的一般信息，认证者及其权益信息，工作链(Workchains)以及分片信息，以及最重要的最近工作链和分片链(Shardchains)的区块 Hash 集合。

2. 工作链(Working blockchains, Workchains): 作为“主力”的工作链最多有 2^32 个，它们包含了交易和只能合约。不同的工作链可能有不同的“规则”，这意味着它们拥有不同的账号地址格式、不同的交易格式、不同的智能合约虚拟机、不同的基础货币等等。然而，它们必须满足某些基本的互操作性标准，才能是不同的工作链之间的交互成为可能并且相对简单。在这方面，TON 区块链是异质(heterogeneous)的，类似于 EOS 和 PolkaDot 项目。

3. 分片链(Shardchains): 每一条工作链最多可以分成 2^60 个分片链。它们具有和工作链相同的规则和区块格式，但本身只负责一个账户子集。换句话说，系统中内置了一种分片形式。 因为所有这些分片链共享一个共同的块格式和规则，所以 TON 区块链在这方面是同质(homogeneous)的，类似于以太坊扩展提议中讨论的内容。

4. 在分片链中的每一个区块事实上并不是区块，而是一条链。通常块区块链或纵向区块链的区块里只包含一个块，然后我们会认为这对应分片链中的一个区块（这种情况下我们称之为“横向区块链”）。但是，如果需要修复不正确的分片链，则需要向纵向区块链中提交一个新的区块，这其中包含无效的横向区块链的块的替换，或者仅包含需要更改此块的先前版本的那些部分的描述。这是一种用于替换检测到的无效块的 TON 特定机制，而不会让分片链分叉，2.1.17将会对此有详细描述。现在，我们仅仅认为每个分片链不是传统的区块链，而将其认为是区块链的区块链或二维区块链。

### 2.1.2 无限分片范式

几乎全部的区块链的分片提议都是“自上而下”的: 首先想象有一条链，然后讨论如何将其拆分成几个交互的分片链，以提高性能并实现可扩展性。

TON 的分片方法是“自下而上”的，解释如下。

想象一下，将分片发挥到极致，那么每一条分片链中只保留一个账户或智能合约。这样我们就会有大量的“账户链”，每个账户链描述一个账户的状态和状态转换，并相互发送消息以传输价值和信息。

当然，拥有数亿条区块链是不切实际的，其中每个区块链通常很少出现更新（即新区块）。 为了更有效地实现它们，我们将这些“帐户链”分组为“分片链”，以便分片链的每个块本质上是已分配给此分片的帐户链块的集合。 因此，“帐户链”在“分片链”中仅具有纯粹的虚拟或逻辑存在。

我们将这种观点称为**无限分片范式**，它解释了 TON 区块链的许多设计决策。

### 2.1.3 消息、即时超立方路由

无限分片范式告诉我们将每个帐户（或智能合约）视为自己的分片链。 那么一个帐户可能影响另一个帐户状态的唯一方法就是向它发送一条消息（这是所谓的 Actor 模型的特殊实例，帐户为 Actors）。 因此，一个不同账户之间的消息系统（因为源账户和目标帐户通常位于不同的分片链中）对于可扩展系统（如TON区块链）至关重要。 实际上，TON 区块链的一个新功能，称为即时超立方路由，使其能够将在一个分片链块中创建的消息传递和处理到目标分片链的下一个块中，而不管系统中分片链的总数。

### 2.1.4 主链、工作链与分片链的数量

TON 区块链只包含一个主链。 但是，该系统最多可以容纳 2^32 个工作链，每个工作链最多可分为 2^60 个分片链。

### 2.1.5 工作链通常是虚拟的链，而不是真实的链

因为工作链通常被细分为分片链，所以工作链的存在是“虚拟的”，这意味着它不是真正的链，而是在下面2.2.1中描述的一般定义——只是一组分片链。 当只有一个分片链对应一个工作链时，这个独特的分片链可以认为是工作链，在这种情况下，工作链至少在一段时间内成为“真正的”区块链，从而获得与传统的单区块链设计的表面相似性。 然而，无限分片范式告诉我们，这种相似性确实是肤浅的: 潜在的大量“账户链”可以暂时归为一条区块链（分片链）仅仅只是一个巧合。

### 2.1.6 工作链的ID

每个工作链由其编号或由一个无符号的32位整数（workchain_id：uint32）标识。 工作链由主链中的特殊交易创建，该交易用于定义（以前未使用的）工作链标识符和工作链的正式描述，以使该工作链与其他工作链可交互以及可对该工作链的块进行验证。

### 2.1.7 工作链的创建与激活

只需准备好支付发布新工作链规范所需的（高）主链交易费用，基本上任何社区成员都可以创建新的工作链。 但是，为了激活新的工作链，需要三分之二的验证人共识，因为他们需要升级他们的软件来处理新工作链的块，并表示它们已经准备好通过特殊的主链交易使新的工作链生效。 对激活新工作链感兴趣的一方可能会通过智能合约分发的一些奖励来为验证人提供一些激励，以便支持新的工作链。

### 2.1.8 分片链的ID

每条分片链由一对元组 (w, s) = (workchain_id，shard_prefix) 标识，其中 workchain_id: uint32 标识相应的工作链，shard_prefix: 2^(0...60) 是一个长度最多为 60 的位串，定义了这个分片链负责的帐户子集。 即所有具有以 shard_prefix 开头的 account_id 的帐户（也就是说将 shard_prefix 作为最高有效位）将被分配给该分片链。

### 2.1.9 账户链的ID

回想一下，帐户链只是虚拟的存在。 但是，它们有一个自然的标识符 - 即 (workchain_id，account_id) - 因为任何帐户链都包含有关状态的信息和正好一个帐户（简单帐户或智能合约）的更新。

### 2.1.10 分片链的动态拆分与合并

一个不太复杂的系统可能使用静态分片。例如，通过使用 account_id 的前八位来选择 256 个预定义分片中的一个。

TON 区块链的一个重要特征是它实现了动态分片，这意味着分片数量是不固定的。相反，如果满足某些条件，则分片 (w，s) 可以自动细分为分片 (w，s.0) 和 (w，s.1)（比如很长一段时间内，原始分片上的交易负载足够高）。 相反，如果负载在一段时间内保持过低，则分片 (w，s.0) 和 (w，s.1) 可以自动合并回 shard (w，s) 。

因此，最初只为 工作链w 创建了一个分片 (w，∅)。 之后如果有必要，它会细分为更多的分片（参见2.7.6和2.7.8）。

### 2.1.11 基本工作链 (Basic Workchain/Workchain Zero)

虽然可以使用特定的规则和交易定义多达 2^32 个工作链，但我们最初只定义了一个工作链，其 workchain_id = 0。此工作链称为 Workchain Zero 或基本工作链，它用于处理 TON 智能合约和转移 TON 代币（也称为 **Gram**，参见附录A）。大多数应用程序可能只需要 Workchain Zero。 基本工作链的分片链将被称为 Basic Shardchains。

### 2.1.12 块生成时间

我们期望在每个分片链和主链中大约每五秒生成一个新块。 这是相当小的交易确认时间。 所有分片链的新块几乎同时生成，并且大约在分片链的新快生成一秒后又生成一个新的主链块，这是因为主链必须包含所有分片链的最新块的哈希值。

### 2.1.13 主链使工作链与分片链紧耦合

一旦分片链块的 Hash 被合并到主链的块中，那么该分片链块及其所有父块就被认为是“规范的”，这意味着它们可以被所有分片链的后续块中引用为固定不变的东西。 实际上，每个新的分片链块也包含最新主链块的 Hash，并且从该主链块引用的所有分片链块被更新的块视为不可变的。

本质上，这意味着在分片链块中提交的交易或消息可以安全地用在其它分片链的下一个块中，而不需要等待。（举个反例: 在大多数的“松散耦合”系统中，用户在转发消息或发送交易之前需要 20 个确认，例如EOS。）而 TON 这种在提交后仅仅五秒就能使用其它分片链中的交易和消息的能力就是我们认为的“紧密耦合”系统（这是同类产品中的第一个），这也是我们能够提供前所未有的性能的原因之一（参见2.8。 12和2.8.14）。

### 2.1.14 主链的块 Hash 也是全局状态

根据2.1.13，从外部观察者的角度来看，最后一个主链块的 Hash 就完全确定了系统的整体状态，所以不需要分别监视所有分片链的状态。

### 2.1.15 通过认证者生成新块

TON 区块链使用 Proof-of-Stake(PoS) 在分片链和主链中生成新块。 这意味着有一组特殊节点通过特殊的主链交易存入权益（大量 TON 代币），以便有资格进行新的块生成和验证。

然后，以确定性伪随机方式将较小的验证人子集分配给每个分片 (w，s)，并且大约每 1024 个块改变一次。 这个验证人子集通过从客户端收集合适的交易到新的有效候选块，并就下一个块的内容达成共识。 对于每个块，在验证人上存在伪随机选择的顺序，以确定哪个候选块具有最高的优先级。

验证人和其它节点检查候选块的有效性; 如果验证人签署了无效候选块，则可能会因此被惩罚一部分或全部的权益，或者在一段时间内不能验证区块的有效性。 在此之后，其它验证人应该对下一个区块的选择达成共识（主要是通过BFT（拜占庭容错;参见2.8.4）共识协议的有效变体，类似于 PBFT [4]或 Honey Badger BFT[11]）。 如果达成共识，则创建新块，并且验证人在它们之间划分交易费，以及一些系统奖励的代币。

每个验证人能够参与进多个不同验证人子集中。在这种情况下，全部的验证与共识都是并行计算的。

在所有的分片链的新块生成之后，或者生成区块超时，主链就会生成新的一个包括所有分片链的最新块哈希值的块。这是由所有验证人的 BFT 共识完成的。

有关 TON PoS 及其经济模型的更多详细信息，请参见第2.6节。

### 2.1.16 主链的分叉

由紧耦合引起的复杂性是，在主链切换到不同的分支几乎必然需要在至少一些分片链中切换到另一个分支。 另一方面，只要主链中没有分叉，就不可能在分片链中分叉。

一般规则是，如果主链中的块 B' 是 B 的前身，B' 包含分片链(w, s) 的块 B'<sub>w, s</sub> 的 HASH(B'<sub>w,s</sub>)，并且 B 包含了 HASH(B<sub>w, s</sub>)，那么 B'<sub>w, s</sub> 一定是 B<sub>w, s</sub> 的前身，否则主链块中的 B 是无效的。

我们预计主链轮叉是罕见的，甚至是不存在的。因为在 TON 区块链采用的 BFT 范例中，只有在大多数验人行为不正确（这将意味着违法者将遭受重大的权益损失）的情况下才能发生这种情况（参见2.6.1和2.6.15）。 因此，预计分片链中也没有真正的分叉。 相反，如果检测到无效的分片链块，它将通过二维区块链的“纵向区块链”机制（参见2.1.17）进行纠正，而不会分叉“横向区块链”（即分片链）。 同样的机制也可用于修复主链块中的非致命错误。

### 2.1.17 更正无效的分片链块

通常，在分片链中必须达到三分之二验证人达成拜占庭共识才能提交新块。 但是，系统必须检测先前提交的无效块以及对其更正。

当然，一旦由由验证人或“渔夫(Fishermen)”（系统的任何节点进行了某种存款，而提出有关区块有效性的问题）找到无效的分片块，签署无效区块的验证人将因此失去部分权益和/或被禁职（后一种措施对于攻击者窃取其他良性验证人的签名密钥的情况很重要）。

但这还不够，因为系统的整体状态由于先前提交的分片块无效而证明是无效的。必须使用较新的有效版本替换此无效块。

大多数系统都会通过“回滚”到此分片链中的无效块之前的最后一个块并且该块不受从其他每个分片链中传播无效块的消息的影响，并从这些块创建新的分叉来实现此目的。 这种方法的缺点是大量的其他正确的和提交的交易突然回滚，并且不清楚它们是否稍后还能被有效确认。

TON 区块链通过使每个分片链和主链（横向区块链）的每个“块”自身成为一个小区块链（纵向区块链）来解决这个问题，这个纵向区块链包含不同版本的“块”或它们的“差异”。 通常，纵向区块链只包含一个区块，而分片链则看起来像一个经典的区块链。 然而，一旦确认块的无效性并在主链块中得到确认，则在纵向上允许在该无效块被新块替换以纠正该无效块。 新块由相关分片链的当前验证人子集生成。

新“纵向”块的有效规则非常严格。特别是，如果无效块中包含有效的虚拟“帐户链块”（参见2.1.2），则必须由新的块更正且保持账户链不变。

一旦在无效块之上提交了新的“纵向”块，其哈希就会发布在新的主链块中（或者更确切地说是在新的“纵向”块中，位于包含最初发布的无效分片块HASH的主链块上方），并且引用了该无效快的所有分片快都会更正。这是通过在纵向区块链中为以前引用“不正确”区块的所有区块提交新的“纵向”区块来解决的; 新的纵向块将引用最新（已更正）的版本。 同样，也禁止更改未受影响的帐户链（即，接收与先前版本相同的消息）。 通过这种方式，修复不正确的块会产生“涟漪”，最终传播到所有受影响的分片链的最新块; 这些变化也反映在新的“纵向”主链块中。

一旦该“涟漪”到达最新的块，新的分片块就作为最新块版本的后继者生成。这意味着它们将从一开始就包含对正确纵向块的引用。

主链状态隐含地定义了将每个“纵向”区块链的第一个块的 HASH 转换为其最新版本的 HASH 的映射。 这使客户端能够通过其第一个（通常是唯一的）块的 HASH 来识别和定位任何纵向区块链。

### 2.1.18 TON 代币与多币工作链

TON 区块链支持多达 2^32 种不同的“加密货币”，由 32 位 currency_id 区分。可通过主链中的特殊交易添加新的加密货币。 每个工作链都有一个基本的加密货币，并且可以有多个额外币种。

有一种特殊的加密货币，currency_id = 0，即 TON 币，也称为 **Gram**（参见附录A）。 它是Workchain Zero 的基本加密货币。它也用于充当手续费和验证人的权益收入。

原则上，其他工作链可能会收取其它代币的交易费用。在这种情况下，应提供一些智能合约，将这些交易费自动转换为 Grams。

### 2.1.19 消息与价值转移

属于相同或不同工作链的分片链可以相互发送消息。 虽然消息的确切形式取决于接收工作链和接收帐户（智能合约），但有一些共同的字段使得工作链之间的消息传递成为可能。 特别地，只要它们被接收工作链声明为可接受的加密货币，那么每个消息可以以一定量的 Gram 和/或其他注册的加密货币的形式附带一些价值。

消息传递的最简单形式是从一个（通常不是智能合约）账户到另一个账户的价值转移。

### 2.1.20 TON 虚拟机

TON虚拟机（也称为 TON VM或 TVM）是用于在主链和基本工作链中执行智能合约代码的虚拟机。 其它工作链可以与 TVM 一起使用别的 TVM。

在这里，我们列出了它的一些功能。 它们将在 2.3.12, 2.3.14 和其它地方进一步讨论。

1. TVM 将所有数据表示为 TVM 单元(cell)的集合（参见2.3.14）。每个单元最多包含 128 个数据字节，4 个对其它单元的引用。 由于“一切都是单元”的理念（参见2.5.14），这使 TVM 能够处理与 TON 区块链相关的所有数据，包括块和区块链全局状态（如有必要）。

2. TVM 可以处理任意代数数据类型的值（2.3.12），其表示为 TVM 单元的树或有向无环图。但是，它并不关心数据类型; 数据类型只适用于单元。

3. TVM 内置了对哈希表(Hashmaps)的支持。

4. TVM 是基于栈的虚拟机。 它的堆栈保持64位整数或单元格引用。

5. 支持 64 位，128 位和 256 位算术。 所有 n 位算术运算有三种形式：无符号整数，有符号整数和 2^n 整数模（后一种情况下不进行自动溢出检查）。

6. TVM 具有从 n 位到 m 位的无符号和有符号整数转换，对于所有 0 ≤ m，n ≤ 256，具有溢出检查。

7. 默认情况下，所有算术运算都执行溢出检查，大大简化了智能合约的开发。

8. TVM 具有 "multiply-then-shift" 和 “shift-then-divide” 算术运算，其中间值以大整数类型计算; 这简化了算术的过程。

9. TVM 支持位串和字符串。

10. 支持预定义的 256 位椭圆曲线加密（ECC），包括Curve25519。

11. 还存在对一些椭圆曲线上的 Weil Pairings 的支持，这对于快速实现zk-SNARK是有用的。

12. 支持流行的哈希函数，包括 SHA256。

13. TVM 支持 Merkle Proofs（参见5.1.9）。

14. TVM 支持“大型”智能合约或“全局”智能合约，而这种智能合约必须要有分片的意识（参见2.3.18和2.3.16）。 通常（本地）智能合约可以是无需考虑分片的。

15. TVM 支持闭包。

16. 可以在TVM内轻松实现“spineless tagless G-machine”。

除了“TVM 汇编语言”之外，还可以为 TVM 设计几种高级语言。 所有这些语言都将具有静态类型，并将支持代数数据类型。 我们设想了以下可能性：

1. 一种类似Java的命令式语言，每个智能合约类似于一个单独的类。

2. 一种惰性函数式语言（类似 Haskell）。

3. 一种快速的函数式语言（类似 ML）。

### 2.1.21 可配置参数

TON 区块链的一个重要特征是它的许多参数都是可配置的。 这意味着它们是主链状态的一部分，并且可以通过主链中的某些特殊提议/投票/结果交易进行更改，而无需任何硬叉。 改变这些参数将需要三分之二的验证人投票和所有其它支持该修改提议的一半以上参与者投票。

## 2.2 TON 区块链的一般概括

### 2.2.1 区块链的一般定义

通常，区块链是一系列首尾相连的块，每个块 B 包含前一个块(blk-prev [B])的引用 （通常通过将前一个块的 HASH 包含在当前块的头部中），以及交易清单。 每个交易描述了全局区块链状态的一些转换; 按顺序将块中的每个交易以某个算法计算，即可获得该块的最新状态。

### 2.2.2 TON 区块链的相关性

回想一下，TON Blockchain 不是传统意义的区块链，而是二维区块链的集合（即区块链的区块链;参见2.1.1），因此上述内容并不直接适用于 TON Blockchain。 但是，我们从传统区块链的这些一般性开始，将其用于构造更复杂结构的系统。

### 2.2.3 区块链实例和区块链类型

人们经常使用区块链这个词来表示一般的区块链类型及其特定的区块链实例。 例如，2.2.1 指的区块链实例。

以这种方式，区块链类型通常是块的列表（即，有限序列）的块(Block<sup>\*</sup>)类型的“子类型”，由满足某些兼容性和有效性条件的那些块序列组成：

> (式1) Blockchain ⊂ Block<sup>\*</sup> 

定义区块链的更好方法是将区块链看作是依赖的耦合类型，由耦合（B，v）组成，第一个组件 B: Block<sup>\*</sup> 是 Block<sup>\*</sup>  列的类型，以及 第二部分 v: isValidBc（B）是B的有效性的证明或见证。如下：

> (式2) Blockchain ≡ Σ<sub>(B:Block<sup>\*</sup>)</sub>*isValidBc*(B)

我们在这里使用从引用[16]的类型依赖和表示法。

### 2.2.4 依赖类型论， Coq 和 TL

请注意，我们在这里使用（Martin-Löf）依赖类型论，类似于在 [Coq](https://coq.inria.fr) 中使用的理论。

依赖类型论的简化版本也用在TL ([Type Language](https://core.telegram.org/mtproto/TL)) ，其将用于 TON 区块链的正式规范中以描述所有数据结构的序列化以及块，交易等的设计。

实际上，依赖类型论给出了证明是什么的有用形式化，例如，当需要为某些块提供无效证明时，这种形式证明（或它们的序列化）可能变得很方便。

### 2.2.5 类型语言 (TL)

由于 TL（类型语言）用于TON 区块、交易和网络数据报的正式规范，因此需要进行简短的讨论。

TL 是一种适用于从属代数类型描述的语言，允许使用数值和类型参数。 通过几个构造函数描述每种类型。 每个构造函数都有一个可读的标识符和一个名称。 除此之外，构造函数的定义包含字段列表及其类型。

构造函数和类型定义的集合称为 TL Scheme。 它通常保存在一个或多个带有后缀 .tl 的文件中。

TL Scheme 的一个重要特征是它确定了一种明确的方式来序列化和反序列化代数类型的值（或对象）。 也就是说，当需要将值序列化为字节流时，首先序列化用于此值的构造函数的名称。之后递归地序列化每个字段。

适用于将任意对象序列化为32位整数序列的 TL 的先前版本的描述可在 https://core.telegram.org/mtproto/TL 获得。 一种名为 TL-B 的 TL 新版本也正在开发，其用于描述 TON 项目的对象序列化。 这个新版本可以将对象序列化为字节流甚至比特流（不仅仅是32位整数），并且支持序列化到 TVM 单元树中（参见2.3.14）。 TL-B 的将是 TON 区块链的正式规范的一部分。

### 2.2.6 区块和交易是状态转换运算符

通常，任何区块链都具有关联的全局状态和交易。 区块链的语义在很大程度上取决于事务函数：

> (式3) *ev_trans′* : Transaction × State → State<sup>\?</sup>

X<sup>\?</sup> 代表 MAYBE X，即把 MAYBE 应用单子 X 的结果。本质上，类型 X<sup>\?</sup> 的值是类型 X 的值或特殊值 ⊥ （表示缺少实际值）。在我们的例子中，我们使用 State<sup>\?</sup> 而不是State 作为结果类型，这是因为如果从某些原始状态调用交易可能是无效的（比如试图从账户中提取比实际存在的更多的钱）。

我们可能更倾向于柯理化的方式表达：

> (式4) *ev_trans* : Transaction → State → State<sup>\?</sup>

因为区块本质上是一个交易列表，所以可以从 *ev_trans* 导出区块评估函数：

> (式5) *ev_block* : Block → State → State<sup>\?</sup>

它表示一个块 B:Block 和前一个区块链状态 s:State（可能包括前一个块的哈希值）并计算下一个区块链状态 `s'= ev_block(B)(s)`，其计算结果可能是 True 或为特殊值⊥（表示无法计算下一个状态。即，如果从给定的起始状态进行计算，则该区块无效 - 例如，该块包括试图从空账户中扣款的交易。）。

### 2.2.7 区块序列号

区块链中的每个块 B 可以通过其序列号 BLK-SEQNO(B) 来引用，从第一个块(0)开始，并且每当传递到下一个块时递增1。 

> (式6) BLK-SEQNO(B) = BLK-SEQNO(BLK-PREV(B)) + 1 

请注意，在存在分支时序列号不会唯一地标识块。

### 2.2.8 区块 HASH

引用块 B 的另一种方式是通过其散列 BLK-HASH(B)来引用，其实际上是块 B 头部的散列（然而，块的头部通常依赖于块 B 的所有内容的散列）。 假设所使用的散列函数没有冲突（或者至少它们是非常不可能的），则通过其散列唯一地标识块。


### 2.2.9 计算 HASH

在对区块链算法进行正式分析前，我们假设使用没有冲突的 k 位散列函数 HASH: Bytes<sup>\*</sup>→2<sup>k</sup>:

> (式7) Hash(s) = Hash(s′) ⇒ s = s′  // for any s, s′ ∈ Bytes<sup>\*</sup> 

这里 Bytes = {0...255} = 2^8 是字节类型，或者是所有字节值的集合，Bytes<sup>\*</sup> 是任意（有限）字节列表的类型或集合; 而2 = {0,1} 是比特类型，而 2<sup>k</sup> 是所有 k 比特序列（即，k比特数）的集合。

当然，(式7) 在数学上是不可能的，因为从无限集到有限集的映射不能是单射的。 一个更严格的假设是:

(式8) ∀s, s′ : s ≠ s′, P (Hash(s) = Hash(s′)) = 2<sup>−k</sup>

但是，这对于证明来说并不方便。 对于某些小ε（例如，ε= 10<sup>-18</sup>），只要我们接受失败概率 ε（即，最终结论将是真实的，概率至少为1  - ε），那么如果（式8）在 2<sup>-k</sup>N < ε 的证明中最多使用 N 次，则我们可以推理（式7）为真。

最后结论：为了使（式8）的概率陈述真正严格，必须在所有字节序列（Byte<sup>*</sup>）的设置上引入概率分布。这样做的一种方法是假设所有相同长度的字节序列都是等概率的，并设置观察长度 l 的序列的概率等于p<sup>l</sup> − p<sup>l+1</sup>。然后（式8）应该被理解为当 p 从向于 1 时的条件概率 `P(Hash(s) = Hash(s′)|s ≠ s′)` 的极限。

### 2.2.10 TON 区块链中使用的 HASH

我们暂时使用 SHA256 作为 TON 区块链的哈希算法。 如果无法满足未来需求，那么将来也可以用另一个哈希函数替换它。 散列函数的选择是协议的可配置参数，因此可以在没有硬分叉的情况下进行更改，如2.1.21中所述。

## 2.3 区块链状态，账户和哈希表

我们在上面已经提到，任何区块链都定义了某个全局状态，每个区块和每个交易都定义了这个全局状态的转换。 这里我们描述 TON 区块链使用的全局状态。

### 2.3.1 账户ID

TON 区块链使用的基本帐户ID（至少是主链和 0 号工作链）使用的是 256 位整数，我们假设它是特定椭圆曲线的 256 位公钥。 

(式9) account_id : Account = uint<sub>256</sub> = 2^256

此处 Account 是帐户类型，而 account_id 是帐户类型的特定变量。

其他工作链可以使用其他帐户 ID 格式。 例如，可以使用比特币风格的帐户 ID，也就是 ECC 公钥的 SHA256。

但是，在创建工作链时必须固定帐户 ID 的位长 l，并且它必须至少为64，因为 account_id 的前64位用于分片和消息路由。

### 2.3.2 重要组件 —— 哈希表（哈希映射）

TON 区块链状态的主要组成部分是哈希表。在一些情况下，我们定义“映射” h: 2<sup>n</sub> -> 2<sup>m</sup>。更一般地说，我们可能对复合类型 X 的哈希映射 h: 2<sup>n</sup> -> X 感兴趣。但是，索引类型几乎总是 2<sup>n</sup>。

有时候，我们有一个空“默认值”: X，而哈希表 h: 2<sup>n</sup> -> X 由其“默认值” i → "empty" 初始化。

### 2.3.3 示例: TON 帐户余额

TON 账户余额给出了一个重要的例子。 这是一个哈希映射:

(式10) balance : Account → uint<sub>128</sub>

它表示 Account 的 uint<sub>128</sub> 余额。此哈希映射的默认值为零，这意味着最初（在处理第一个块之前）所有帐户的余额为零。

### 2.3.4 示例：智能合约的持久化存储

另一个例子是智能合约的持久化存储，它可以（非常近似地）表示为哈希映射:

(式11) storage : 2<sup>256</sup> -> 2<sup>256</sup>

此映射也具有默认值零，这意味着未初始化的持久存储单元为零。

### 2.3.5 示例：所有智能合约的持久化存储

因为我们有多个智能合约，分别由 account_id 区分，每个都有独立的持久化存储，因此我们必须有一个哈希表：

(式12) Storage : Account -> (2<sup>256</sup> -> 2<sup>256</sup>)

将智能合约的 account_id 映射到持久化存储中。

### 2.3.6 哈希映射类型

哈希映射不仅仅是一个抽象的（部分定义的）函数 2<sup>n</sup> -> X; 它有一个规范的表示。因此，假设我们有一个特殊的哈希映射类型:

> (式13) Hashmap(n,X) : Type

对应于（部分）数据结构的编码映射 2<sup>n</sup> -> X。我们也可以写

> (式14) Hashmap(n : nat)(X : Type) : Type

或

> (式15) Hashmap : nat → Type → Type

我们总是可以将 h: Hashmap(n, X) 转换为映射 hget(h): 2<sup>n</sup> -> X<sup>\?</sup>。从此以后，我们通常写 h[i] 而不是 hget(h)(i):

(式16) h[i] :≡ hget(h)(i) : X<sup>\?</sup> for any i: 2n, h: Hashmap(n,X)

### 2.3.7 将哈希映射类型定义为 Patricia 树

从逻辑上讲，可以将 Hashmap(n, X) 定义为深度为 n 的（不完整）二叉树，边缘标为 0 和 1，叶节点的值为 X。 描述相同结构的另一种方式是对于长度等于 n 的二进制串（按位）trie。

在实践中，我们更喜欢使用 trie 的紧凑表示，通过压缩每个顶点，使只有一个子节点对应其父节点。 其结果表示称为 Patricia 树或二进制基数树。 现在每个中间顶点都只有两个由非空二进制字符串标记的子节点，左边的子节点为零，右边的子节点为1。

换句话说，Patricia 树中有两种类型的（非根）节点:

1. Leaf(x)，包含 X 类型的值 x。

2. Node(l, s<sub>l</sub>, r, s<sub>r</sub>)，其中 l 引用左子节点或子树，s<sub>l</sub> 是标记连接此顶点到其左子节点的边的位串（始终以0开头），r是右子树，s<sub>r</sub> 是标记连接此顶点到右子节点的位串（总是以1开头）。

第三种类型的节点，仅用于 Patricia 树的根节点：

1. Root(n, s<sub>0</sub>, t)，其中 n 是 Hashmap(n, X) 的索引位串的公共长度，s<sub>0</sub> 是所有索引位串的公共前缀，t 是对 Leaf 或 Node 的引用。

如果我们想让 Patricia 树为空，那么需要使用第四种类型的（根）节点：

1. EmptyRoot(n)，其中n是所有索引位串的公共长度。

我们通过下式定义 Patricia 树的高度：

> (式17) HEIGHT(LEAF(x)) = 0

> (式18) HEIGHT(NODE(l, s<sub>l</sub>, r, s<sub>r</sub>)) = HEIGHT(l) + LEN(s<sub>l</sub>) = HEIGHTt(r) + LEN(s<sub>r</sub>)

> (式19) HEIGHT(Root(n, s<sub>0</sub>, t)) = LEN(s<sub>0</sub>) + HEIGHT(t) = n

最后两个公式中每个公式中的最后两个表达式必须相等。 我们使用高度为 n 的 Patricia 树来表示 Hashmap(n, X) 类型的值。

如果树中有 N 个叶子（即我们的 Hashmap 包含 N 个值），则恰好有 N-1 个中间顶点。 插入新值总是涉及通过在中间插入新顶点并添加新叶作为此新顶点的另一个子节点来分割现有边。 从散列映射中删除值则相反：删除了一个叶子及其父级，并且父级的父级和另一个子级直接链接。

### 2.3.8 Merkle-Patricia 树

使用区块链时，我们希望能够能将它们化减为单个哈希值来比较 Patricia 树（即哈希图）及其子树。Merkle 树给出了实现这一目标的经典方法。 本质上，我们需要借助为二进制字符串定义的散列函数，才能计算对象的散列 Hash(x) x: X 的二进制序列化，而达到我们想要描述一种散列 Hashmap(n, X) 类型的对象 h 的方法。

可以递归地定义 Hash(h)，如下所示：

> (式20) Hash(Leaf(x)) := Hash(x)

> (式21) Hash((l, s<sub>l</sub>, r, s<sub>r</sub>)) := Hash(Hash(l). Hash(r). Code(s<sub>l</sub>). Code(s<sub>r</sub>))

> (式22) Hash(Root(n, s<sub>0</sub>, t)) := Hash(Code(n). Code(s<sub>0</sub>). Hash(t))

这里 s.t 表示（位）字符串 s 和 t 的串联，并且 Code(s) 是所有位串 s 的前缀代码。

稍后我们将看到（参见2.3.12和2.3.14）这是一个（稍微调整过的）递归定义的哈希值，用于任意（从属）代数类型的值。

### 2.3.9 重新计算 Merkle 树的哈希值

这种递归定义 Hash(h) 的方式，称为 Merkle 树哈希，具有以下优点：如果显式地存储 Hash(h') 以及每个节点 h'（例如，一个 Merkle-Patricia 树）在添加删除或更改元素时仅需要最多重新计算 n 个哈希值。

这样，如果通过合适的 Merkle 树哈希表示全局区块链状态，则在每次交易发生后很容易重新计算此哈希状态。

### 2.3.10 Merkle 证明

在式7的假设下，可以构造一个证明，对于给定值 z 的 Hash(h)， h: Hashmap(n, X)，对于某些 i: 2n 和 x: X 可得 hget(h)(i) = x。这样的证明将涵盖 Merkle-Patricia 树中从对应于 i 到根的路径，且在该路径上的所有节点以及所有兄弟节点的哈希。

以这种方式，轻节点就可以从全节点那里获取部分信息证明数据的有效性。

在一些情况下，客户端可能想要获得值 y = Hash(x) = Hash(h[i]) 而不是散列图本身， 那么可以提供 (i，y) 的 Merkle 证明。 如果 x 也是哈希图，则可以从全整节点获得开始从 y = Hash(x) 的 Merkle 证明，以提供值 x[j] = h[i][j] 或仅哈希值。

### 2.3.11 对于 TON 这样的多链系统，Merkle 证明的重要性

请注意，节点通常不是 TON 中存在的所有分片链的完整节点。节点通常只是一些分片链的完整节点（那些包含自己的帐户，它感兴趣的智能合约，或者这个节点被指定为验证人的那些）。对于其他分片链，它一定是一个轻节点，否则存储，计算和网络带宽要求将是令人望而却步的。这意味着这样的节点不能直接检查关于其他分片链状态; 它必须依赖从完整节点获得的那些分片链的 Merkle 证明，通常这与自我验证一样安全，除非 (式7) 失败 （比如 Hash 冲突）。

### 2.3.12 TON VM 的特点

用在主链和零工作链中运行智能合约的 TON VM 或 TVM（Telegram Virtual Machine）与受 EVM（Ethereum Virtual Machine）启发的传统设计有很大不同。TVM 不仅适用于 256 位整数，而实际上适用于（几乎）任意“数值”，“结构”或“和积类型”，使其更适合执行高级（特别是函数式）语言。 从本质上讲，TVM 使用标记数据类型，与 Prolog 或 Erlang 的实现中使用的数据类型不同。

人们可能首先想到的是，TVM 智能合约的状态不仅仅是一个散列图，而是 Hashmap(256, X)，X 是具有多个构造函数，使其能够存储除 256 位整数之外的其他数据结构的类型，特别是包括其它 Hashmap(256, X)。这意味着 TVM（持久或临时）存储的单元，或 TVM 智能合约代码中的变量或数组元素不仅可以包含整数，而且可以包含全新的散列映射。当然，这意味着一个单元不仅有 256 位，而且还包含一个 8 位标签，用于描述如何解释这 256 位。

实际上，值不需要精确为 256 位。 TVM 使用的值格式由一系列原始字节和对其他结构的引用组成，以任意顺序混合，一些描述符字节插入合适的位置，以便能够区分指针与原始数据（例如，字符串或整数）; 参见2.3.14。

该原始值格式可用于实现任意和积代数类型。 在这种情况下，该值首先包含一个原始字节，描述正在使用的“构造函数”（从高级语言的角度来看），然后是其他“字段”或“构造函数参数”，由原始字节组成 并根据所选的构造函数引用其他结构（参见2.2.5）。  但是，TVM 对构造函数与其参数之间的对应关系一无所知; 字节和引用的混合由某些描述符字节显式描述。

Merkle 树散列扩展到任意这样的结构：为了计算这种结构的散列，所有引用都被递归的对象散列替换，然后计算得到的字节串（包括描述符字节）的散列。

通过这种方式，2.3.8 中描述的用于散列图的 Merkle 树散列，只是对任意（从属）代数数据类型应用于具有两个构造函数的 Hashmap(n, X) 类型进行散列的特殊情况。

### 2.3.13 TON 智能合约的持久化存储

TON 智能合约的持久化存储基本上由其“全局变量”组成，在智能合约的调用之间保留。 因此，它只是一个由正确类型的字段组成的 "product"，"tuple" 或 "record" 类型，每个字段对应一个全局变量。 如果全局变量太多，则由于对 TON 单元大小的全局限制，它们不能存放进一个 TON 单元。 在这种情况下，它们被分成若干记录并组织成树，基本上成为 "product of products" 或 "product of products of products" 类型，而不仅仅是 "product" 类型。

### 2.3.14 TVM 单元

TON VM 将所有数据保存在（TVM）单元集合中。 每个单元首先包含两个描述符字节，指示该单元中存在多少字节的原始数据（最多 128 个）以及存在多少个对其他单元的引用（最多 4 个）。 然后是这些原始数据字节和其它单元引用。 每个单元格只引用一次，因此我们可能在每个单元格中也包含对其“父”单元的引用。

以这种方式，TON 智能合约的持久化数据存储单元被组织成树，其中引用了保存在智能合约描述中的该树的根。 如有必要，从叶节点开始递归计算整个持久化存储器的 Merkle 树哈希，然后递归替换掉引用单元，并随后计算由此获得的数据的哈希值。

### 2.3.15 任意代数类型值的广义Merkle证明

因为 TON VM 通过由（TVM）单元组成的树来表示任意代数类型的值，并且每个单元具有明确定义的（根据该单元格生成的整个子树的） Merkle 哈希， 所以我们可以为任意代数类型的（部分）值提供“广义 Merkle 证明”，旨在证明具有已知 Merkle 散列的树的某个子树采用特定值或具有特定散列的值。 这概括了2.3.10其中只考虑了 x[i] = y 的 Merkle 证明。

### 2.3.16 TON VM 数据结构中的分片支持

我们刚刚概述了 TON VM 如何在不过度复杂的情况下支持高级智能合约语言中的任意（相关）代数数据类型。 但是，大型（或全局）智能合约的分片需要在 TON VM 级别上提供特殊支持。 为此，系统中添加了特殊版本的 Hashmap 类型，相当于“映射” Account -> X. 这个“映射”似乎等同于 Hashmap(m, X)，其中 Account = 2<sup>m</sup>。 但是，当分片分成两个子分片或两个分片合并时，这些 Hashmap 会自动拆分为两个或合并回来，以保留属于相应分片的那些 Key。

### 2.3.17 为持久化存储支付

TON 区块链的一个值得注意的特征是从智能合约中支付用于其持久化的数据存储（例如，扩大区块链的状态）。 它的工作原理如下：

每个块声明两个价格（通常是用 Gram 计价）：将一个单元保留在持久化存储中的价格，以及在持久化存储的某个单元中保留一个原始字节的价格。 每个帐户使用的单元和字节总数的统计信息存储为其状态的一部分，因此通过将这些数字乘以块中声明的两个费率，我们可以计算出要从帐户余额中扣除的付款以便保留它在前一个块和当前块之间的数据。

但是，对于每个帐户和每个块中的智能合约，不强制要求为持久化存储付款; 相反，该支付最后被执行的块的序列号存储在帐户数据中，并且当对该帐户进行任何操作时（例如，通过智能合约接收和处理价值转移或消息）， 自执行任何进一步操作之前从帐户余额中扣除上一次此类付款以来所有块的存储使用付款。 如果此后帐户的余额将变为负数，则该帐户将被销毁。

工作链可以声明每个帐户的一些原始数据字节是“免费”的，以便于创建 "simple" 帐户，这些帐户仅保留一个或两个加密货币，以免除这些付款。

请注意，如果没有人向帐户发送任何消息，则不会收集其持久化存储的费用，并且它可以无限期地存在。 但是，任何人都可以发送一条空消息来销毁这样的帐户。这样，要销毁的帐户的原始余额的一部分会被收集起来，以激励这样的消息的发送者。 但是，我们预计验证人将免费销毁此类无力偿债的账户，只是为了减少全局区块链的规模，以避免在没有补偿的情况下保留大量数据。

### 2.3.18 本地和全局智能合约；智能合约实例

根据智能合约 account_id 确定的智能合约通常只存在于一个分片中，这和“普通”账户类似。 对于大多数应用来说，这通常就足够了。 然而，一些“高负荷”的智能合约可能希望在某些工作链的每个分片链中都有一个“实例”。 为了实现这一点，必须将它们的创建交易传播到所有分片链中，并支付大笔手续费。

此操作有效地在每个分片中创建智能合约的实例，并具有单独的余额。 最初，在创建交易中传输的余额只是通过在 shard(w, s) 中给出 2<sup>-|s|</sup> 的总余额一部分来分配。 当分片分成两个子分片时，所有全局智能合约实例的余额分成两半; 当两个分片合并时，余额会加在一起。

在某些情况下，拆分/合并全局智能合约的实例可能涉及（延迟）执行这些智能合约的特殊方法。 默认情况下，如上所述拆分和合并余额，以及一些特殊的“帐户索引”哈希表也会自动拆分和合并（参见2.3.16）。

### 2.3.19 智能合约的拆分限制

全局智能合约可能会在创建时限制其拆分深度 d，以便使持久化存储费用更具可预测性。 这意味着，如果 shardchain(w, s) 与 |s| ≥ d 分为两部分，两个新的分片链中只有一个继承了智能合约的一个实例。 对这种情况有明确的定义：每个全局智能合约都有一些 account_id，它本质上是其创建交易的哈希值，并且其实例具有相同的account_id，其中第一个 ≤d 位替换为正确分片所需的适当值。 在拆分后的该 account_id 分片将继承智能合约实例。

### 2.3.20 账户/智能合约状态

我们可以总结以上所有内容，得出结论：帐户或智能合约状态包含以下内容：

1. 基础货币的余额
2. 其他货币的余额
3. 智能合约代码（或其哈希）
4. 智能合约的持久化数据（或其Merkle哈希）
5. 有关持久化存储单元数和使用的原始字节数的统计信息
6. 智能合约持久存储的付款的最近时间（实际上是主链块号）
7. 转移货币并从此帐户发送消息所需的公钥（可选; 默认情况下等于 account_id 本身）。 在某些情况下，类似于比特币交易输出所做的，可以在此处找到更复杂的签名检查代码; 然后 account_id 将等于此代码的哈希值。

我们还需要在帐户状态或其他一些帐户索引的 Hashmap 中保留以下数据：

1. 帐户的输出消息队列（参见2.4.17）
2. 最近发送消息的哈希值（参见2.4.23）

并非所有的信息都是每个帐户必须需要的; 例如，智能合约代码仅适用于智能合约，但不适用于“简单”账户。 此外，虽然任何账户必须具有主要货币的非零余额（例如，基本工作链的主链和分片链的 Gram），但其它货币的余额可能为零。 为了避免保留未使用的数据，在工作链的创建期间定义了一个 sum-product 类型，它使用不同的标记字节（例如，TL构造函数;参见2.2.5）来区分不同的“够造函数“。 最终，帐户状态本身被保存为 TVM 持久化存储的单元集合。

## 2.4 分片链之间的消息

TON 区块链的一个重要组成部分是区块链之间的消息传递系统。 这些区块链可以是相同工作链的分片链，也可以是不同工作链的分片链。

### 2.4.1 消息，帐户和交易的概览

消息从一个帐户发送到另一个帐户。 每个交易包括一个接收该消息的帐户，根据某些规则更改其状态，以及向其他帐户生成多个（可能是一个或零个）新消息。 每条消息都会生成并接收（传递）一次。

这意味着消息在系统中起着至关重要的作用，与帐户（智能合约）相当。 从无限分片范式（参见2.1.2）的角度来看，每个帐户都在其独立的“帐户链”中，并且它影响其他帐户状态的唯一方法是发送消息。

### 2.4.2 账户作为参与者 —— 参与者模型(Actor Model)

有人可能会将帐户（和智能合约）视为“流程”或“参与者”，它们能够处理传入的消息，更改其内部状态并生成一些出站消息。 这与所谓的 Actor 模型密切相关，在 Erlang等语言中使用（然而，Erlang中的actor通常称为 "processes"）。 由于处理入站消息的结果也允许现有参与者创建新的参与者（即，智能合约），因此与 Actor 模型的对应基本上是完整的。

### 2.4.3 消息接收者

任何消息都有其接受者，其特征是目标工作链标识符 w（默认情况下假定与发起的分片链相同）和收件人帐户 account_id。 account_id 的确切格式（即比特数）取决于 w; 但是，分片始终由其第一个（最重要的） 64 位确定。

### 2.4.4 消息发送者

在大多数情况下，消息具有发送者，再次由 (w', account_id') 表示。 如果存在，则它位于消息收件人和消息值之后。 有时，发送者不重要或者不属于区块链（即，不是智能合约），在这种情况下，该字段不存在。

请注意，Actor 模型不要求消息具有隐式发送方。 相反，消息可以包含对应该发送请求的 Actor 引用，通常它与发送者一致。 但是，在加密货币（拜占庭）环境中的消息中具有显式的不可伪造的发送者字段是有用的。

### 2.4.5 消息（价）值

消息的另一个重要特征是其附带的消息（价）值，由源和目标工作链支持的一个或多个加密货币。 消息的值在消息接收者之后立即显示; 它本质上是 (currency_id, value) 对的列表。

请注意，“简单”帐户之间的“简单”值转移只是空（无操作）消息，并附加了一些（价）值。 另一方面，稍微复杂的消息体可能包含简单的文本或二进制注释（例如，关于支付的目的）。

### 2.4.6 外部消息，或“来自任意地方的消息”

有些消息“无处不在”地进入系统 - 也就是说，它们不是由位于区块链中的帐户（智能合约或非智能合约）生成的。 当用户想要将一些资金从她控制的账户转移到其他账户时，就会出现最典型的例子。 在这种情况下，用户将“来自任何地方的消息”发送到她自己的帐户，请求它生成带有指定值的接收帐户的消息。 如果此消息已正确签名，则她的帐户会收到该消息并生成所需的出站消息。

实际上，人们可能会将“简单”帐户视为具有预定义代码的智能合约的特例。 这个智能合约只接受一种消息。 这样的入站消息必须包含由入站消息而生成的出站消息列表以及签名。 智能合约检查签名，如果正确，则生成所需的消息。

当然，“来自任意地方的信息”与正常信息之间存在差异，因为“来自任意地方的信息”不能承担价值，因此它们不能自己支付它们的 "Gas"。 相反，在被收集到新的区块之前，他们暂时执行了一小段代码; 如果执行失败（签名不正确），则“来自任意地方的消息”被认为是不正确的并被丢弃。 如果执行没有失败，则该消息可以包括在新的区块中并且完全处理，并从接收者的账户中扣除 Gas 的费用。 “来自任意地方的消息”还可以定义一些交易费，用于再分配给验证人的燃料费，该费用在接收方的帐户中扣除。

在这个意义上，“来自任意地方的消息”或“外部消息”承担在其他区块链系统（例如，比特币和以太坊）中交易候选者的角色。

### 2.4.7 日志消息，或“去往任意地方的消息”

类似地，有时可以生成特殊消息并将其路由到特定的分片链，不是将其传递给其接收者，而是记录以便任何人都可以容易地观察到。 这些日志消息可以在用户的控制台中输出，或者触发在 off-chain 服务器上执行某些脚本。 从这个意义上讲，它们代表了“区块链超级计算机”的外部“输出”，就像“来自任意地方的消息”代表“区块链超级计算机”的外部“输入”一样。

### 2.4.8 与 off-chain 服务和外部区块链交互

这些外部输入和输出消息可用于与链下(off-chain)服务和其他（外部）区块链（如比特币或以太网）进行交互。 有人可能会在 TON Blockchain 内部创建 Token 或其它加密货币，这些货币链与比特币，Ethers 或以太网区块链中定义的任何 ERC-20 代币挂钩，并使用“来自任意地方的消息”和“去往任意地方的消息”，由脚本生成和处理 驻留在某些第三方链下服务器上，以实现 TON 区块链与这些外部区块链之间的必要交互。

### 2.4.9 消息体

消息体只是一个字节序列，其含义仅由接收工作链和/或智能合约确定。 对于使用 TON VM 的区块链，可以通过被 Send() 生成的任何 TVM 单元自动序列化。 最终，出现一串通常由 4 字节“消息类型”或“消息构造函数”作为前缀的原始字节，用于选择接收智能合约的正确方法。

另一种选择是使用 TL 序列化对象（参见2.2.5）作为消息体。 这对于不同工作链之间的通信尤其有用，其中一个或两个工作链不一定使用 TON VM。

### 2.4.10 Gas 限制和其他工作链/VM特定参数

有时，消息需要携带有关 Gas 限制，Gas 价格，交易费用和依赖仅与接收工作链相关的货币信息。并且，这些参数包含在消息体中或之前，有时（取决于工作链）具有特殊的4字节前缀表明它们的存在（可以通过TL方案定义;参见2.2.5）。

### 2.4.11 创建消息：智能合约和交易

新消息来源主要有两个。 大多数消息是在智能合约执行期间（通过 TON VM 中的 Send() ）创建的，此时调用某个智能合约来处理传入消息。 或者，消息可能来自外部，作为“外部消息”或“来自任意地方的消息”（参见2.4.6）。

### 2.4.12 消息分发

当消息到达包含其目标帐户的分片链时，它将被“传递”到其目标帐户。 接下来会发生什么取决于工作链; 从外部的角度来看，重要的是这样的消息永远不能从这个分片链进一步转发。

对于基本工作链的分支链，消息附带的价值（减去任何 Gas 费用）将添加到接收帐户的余额中，并且如果接收帐户是智能合约就可能在之后调用接收智能合约消息的相关方法。 实际上，智能合约只有一个用于处理所有传入消息的入口点，它必须通过查看它们的前几个字节来区分不同类型的消息（例如，包含TL构造函数的前四个字节;参见2.2.5）。

### 2.4.13 交易是消息分发的载体

因为消息的传递改变了帐户或智能合约的状态，所以它是分片链中的特殊交易。 基本上，所有 TON 区块链交易都包括向其接收账户（智能合约）交付一个入站消息（忽略一些小的技术细节）。

### 2.4.14 同一智能合约实例之间的消息

回想一下，智能合约可能是本地的（即，像任何普通账户一样驻留在一个分片链中）或全局的（即，在所有分片中具有实例，或者至少在所有分片中具有某个已知深度 d ;参见2.3.18）。 如果需要，全局智能合约的实例可以交换特殊消息以在彼此之间传递信息和价值。 在这种情况下，（不可伪造的）发件人 account_id 变得很重要（参见2.4.4）。

### 2.4.15 发送给任何智能合约实例的消息; 通配符地址

有时，消息（例如，客户端请求）需要被传递到全局智能合约的任何实例，通常是最接近的一个实例（例如，如果存在与发送者相同的分片链中的一个，则它是明显的候选者）。 一种方法是使用“通配符收件人地址”，允许目标 account_id 的前 d 位采用任意值。 实际上，通常会将这些 d 位设置为与发送方的 account_id 中相同的值。

### 2.4.16 不存在输入队列

由区块链（通常是分片链; 有时是主链）接收的所有消息 - 或者由驻留在某个分片链内的“帐户链”立即分发（即，由接收帐户处理），因此，没有“输入队列”。 相反，由于块的总大小和 Gas 使用的限制，并非所有发往特定分片链的消息都可以被处理，则一些消息只能被累积在原始分片链的输出队列中。

### 2.4.17 输出队列

从无限分片范例（参见2.1.2）的角度来看，每个账户链（即每个账户）都有自己的输出队列，包括它已生成但尚未发送给收件人的所有消息。 当然，账户链只是虚拟存在; 它们被分组到分片链中，而分片链有一个输出“队列”，它由属于分片链的所有帐户的输出队列的并集组成。

此分片链输出“队列”仅对其成员消息部分顺序。 也就是说，前一个块中的消息必须在后续块之前被分发，并且同一帐户生成任何消息必须按照它们生成的顺序传递。

### 2.4.18 快速可靠的链间消息传递

对于像 TON 这样的可扩展多区块链项目来说，能够在不同的分片链之间转发和传递消息（参见2.1.3）是至关重要的。 消息应该可靠地（即，消息不应丢失或不止传送一次）并且快速传送。 TON 区块链通过结合使用两个“消息路由”机制实现了这一目标。

### 2.4.19 超立方路由：确保消息传递的“缓慢通道”

TON 区块链使用“超立方路由”(hypercube routing)作为一种缓慢但安全可靠的方式，将消息从一个分片链传递到另一个分片链，如有必要，可使用多个中间分片链进行传输。 如果不通过这种方式，那么任何给定的分片链的验证人都需要跟踪所有其他分片链的状态（输出队列），这将需要大量的计算能力和网络带宽，因为随着分片链的总量增长，系统的可扩展性会受到更多限制。 因此，无法直接从任何分片向其他分片传递消息。 相反，每个分片仅“连接”到不同于其 (w, s) 分片标识符的一个十六进制数字的分片（参见2.1.8）。 这样，所有的分片链都构成了一个“超立方体”，并且消息沿着这个超立方体的边缘传播。

如果将消息发送到与当前分片不同的分片，则当前分片标识符的一个十六进制数字（确定性地选择）将被目标分片的相应数字替换，并且所得到的标识符将用作消息转发的最近目标分片。

超立方体路由的主要优点是验证人必须收集并处理来自“相邻”分片链的输出队列的消息，以免丢失它们的权益。 通过这种方式，可以预期任何消息迟早会到达其最终目的地; 消息不会在传输过程中丢失或交付两次。

请注意，超立方体路由引入了一些额外的延迟和费用，因为必须通过几个中间的分片链转发消息。 然而，这些中间分片链的数量增长非常缓慢。

### 2.4.20 即时超立方路由：消息传递的“快速通道”

TON 区块链的一个新特点是它引入了一条“快速通道”，用于将消息从一个分片链转发到任何其他分片链，允许在大多数情况下完全绕过 2.4.19 的“慢”超立方体路由并将消息传递到最后一个目的分片链的下一个区块。

在“慢”超立方体路由中，消息沿着超立方体的边缘（在网络中）传播，但会在每个中间节点处延迟大约五秒后继续在传播到相应的分片链中。

为了避免不必要的延迟，可以使用沿超立方边缘的适当 Merkle 证明来中继消息，而无需将其提交到中间的分片链中。 实际上，网络消息应该从原始分片的“任务组”（参见2.6.8）的验证人转发到目标分片的指定块生成者的“任务组”中（参见2.6.9）。 这可以不需要沿着超立方体的边缘传递而直接完成。 当带有 Merkle 证明的消息到达目的分片的验证人时，它们可以立即将其提交到新的块中。 然后沿着超立方体边缘发送回传确认以及合适的 Merkle 证明，并且可以通过提交特殊交易来用于停止消息的传递。

请注意，这种“即时分发”机制并不能取代 2.4.19 中描述的“慢速”机制。 因为验证器不能因丢失或决定不将“快速通道”消息提交到其区块链的新块而受到惩罚，所以仍然需要“慢速通道”。

因此，两种消息分发方法都是并行运行的。只有在将“快速”机制的消息成功提交到中间分片链时才会中止“慢速”机制。

### 2.4.21 从邻近的分片链的输出队列中收集输入消息

当分片链的新块产生时，相邻分片链的一些输出消息将会作为“输入”消息被包括在新块中并立即传送（处理）。 存在某些规则来处理这些邻居的输出消息的顺序。 基本上，任何“较旧”消息会在“较新”消息之前被传递; 而对于来自相同的相邻分片链的消息，必须遵守2.4.17中描述的顺序。

### 2.4.22 从输出队列中删除消息

一旦观察到输出队列消息已经被相邻的分片链传递，它就会被特殊的消息从输出队列中显式删除。

### 2.4.23 防止消息双重传递

为了防止从相邻分片链的输出队列中获取的消息双重传递，每个分片链（更确切地说，其中的每个帐户链）将最近传递的消息（或仅仅是它们的哈希）的集合保持为其状态的一部分。 当观察到传递的消息由其始发的相邻分片链从输出队列中删除时（参见2.4.22），它也会从最近传递的消息的集合中删除。

### 2.4.24 转发用于其它分片链的消息

超立方路由（参见2.4.19）意味着有时出站消息不会传递到包含预期接收者的分片链上，而是传递到位于目的地分片链的相邻分片链上。 在这种情况下，“传递”是指将入站消息移动到出站队列。 这在块中显式地反映为包含消息本身的特殊转发消息。 从本质上讲，这看起来好像是分片链中的某个人收到了消息，并且结果生成了一条相同的消息。

### 2.4.25 为转发和消息保留付费

消息转发实际上花费了一些 Gas（取决于转发的消息大小），因此该分片链的验证人会从消息中扣除 Gas 费。 即使该消息由于超立方体路由而被多次转发，转发费也通常远小于当消息最终传递给其接收者时所支付的 Gas 费。 此外，只要消息保存在某个分片链的输出队列中，它就是分片链全局状态的一部分，因此长时间保存的全局数据费用也会被收集起来要求支付。

### 2.4.26 发送至主链和来自主链的消息

消息可以直接从任何分片链发送到主链，反之亦然。 但是，在主链中发送消息和处理消息的 Gas 价格非常高，因此只有在真正需要时才会使用此功能 - 例如，验证人需要存入他们权益的时候。 在某些情况下，发送到主链消息的最小价值是被预定义的，仅当消息被接收方视为“有效”时才会退回。

消息无法通过主链自动路由。workchain_id̸ ≠ -1 的消息（-1是表示主链的特殊 workchain_id）无法传递给主链。

原则上，可以在主链内创建消息转发智能合约，但使用它的价格会较高。

### 2.4.27 同一个分片链中帐户之间的消息

在某些情况下，由某个分片链的帐户生成的消息发往同一个分片中的另一个帐户。 例如，这发生在一个尚未拆分为多个分片的新工作链中。

此类消息可能会累积在分片链的输出队列中，然后作为后续块中的传入消息进行处理（为此目的，任何分片都被视为其自身的邻居）。 但是，在大多数情况下，可以在原始块本身内传递这些消息。

为了实现这一点，分发到相同账户的消息就会被局部排序，并且对分片块中包括的所有交易进行这样的局部排序。 特别地，允许一个交易的输出消息优先于更早的交易被处理。

在这种情况下，消息体不会被复制两次。 相反，原始的和正在被处理的交易引用的是相同的消息。

## 2.5 全局分片状态

现在我们准备描述 TON 区块链的全局状态，或者至少是基本工作链的分片状态。

我们从包括全局分片链状态的“高级”或“逻辑”开始描述。

### 2.5.1 分片链状态是帐户链状态的集合

根据无限分片范式（参见2.1.2），任何分片链只是一个（临时）虚拟“帐户链”集合，每个账户链只包含一个帐户。 这意味着，本质上，全局分片链状态必须是一个 Hashmap:

> (式23) ShardchainState := (Account -> AccountState)

如果我们正在讨论分片链(w, s)的状态，那么所有出现在这个 Hashmap 索引中的 account_id 必须以前缀 s 开头。

实际上，我们希望将 AccountState 分成几个部分（例如，将帐户输出消息队列分开以简化其相邻分片链的验证），并在 ShardchainState 内部设置若干个哈希映射 (Account-> AccountStateParti)。 我们还可以向 ShardchainState 添加少量“全局”或“必要”参数（例如，属于该分片的所有帐户的总余额，或所有输出队列中的消息总数）。

然而，从“逻辑”（“高级”）的角度来看，(式23) 至少看起来是分片链全局状态的良好近似。 AccountState 和 ShardchainState 的形式描述可以借助 TL Scheme（参见2.2.5）完成。

### 2.5.2 拆分和合并分片状态

请注意，无限分片范例描述显示了在分割或合并分片时应如何处理此状态 (式23) 。 实际上，使用哈希映射，这些状态转换将变得非常简单。

### 2.5.3 账户链状态

（虚拟的）帐户链状态只是一个帐户的状态，由 AccountState 类型描述。 通常它具有 2.3.20 中列出的全部或部分字段，但具体取决于所使用的构造函数。

### 2.5.4 全局工作链状态

与（式23）类似，我们可以通过相同的公式定义全局工作链状态，但允许 account_id 是任何值，而不仅仅是属于一个分片的值。 类似于 2.5.1 中的注释也适用于这种情况：我们可能将此 Hashmap 拆分为几个 Hashmap，也可能添加一些“必要”参数，例如总余额。

本质上，全局工作链状态必须由 ShardchainState 作为分片链状态给出，因为工作链的状态是所有现有的分片合并为一个所得到的状态。

### 2.5.5 低级视角：“单元集合”

帐户链或分片链状态的“低级”描述也是对上面给出的“高级”描述的补充。 这个描述非常重要，因为为网络，存储，序列化和传输几乎所有 TON 区块链使用的数据提供了通用基础（块，分片状态，智能合约存储，Merkle 证明等）。 同时，这种普遍的“低级”描述一旦被理解和实施，就可以使我们只关注“高级”视角。

回想一下，TVM 通过 TVM 单元树或简称单元（参见2.3.14和2.2.5）表示任意代数类型的值（例如，包括 (式23) 的 ShardchainState）。

任何这样的单元由两个描述符字节组成，定义了某些标志和值，原始字节数(0 ≤ b ≤ 128)，和对其他单元的引用数量 (0 ≤ c ≤ 4)。

单元的确切格式取决于实现以及单元是位于 RAM，磁盘，网络数据包，块中等等。 一个有用的抽象模型在于想象所有单元都保存在内容可寻址的内存中，单元格的地址等于其（SHA256）哈希。 回想一下，单元的（Merkle）散列是通过用它们的（递归计算的）散列替换对其子单元的引用并对生成的字节串进行散列来精确计算的。

以这种方式，如果我们使用单元哈希值来引用单元就能让系统稍微简化，并且单元哈希值的起始值与表示它的字节串的哈希值一致。

现在我们看到 TVM 表示的任何对象，包括全局分片状态，都可以表示为“一袋单元”，即一组单元以及对这组单元的一个“根”引用（例如，通过哈希）。 请注意，此描述中删除了重复的单元（“一袋单元”是一组单元，而不是多个单元集合），因此抽象树实际上可以被表示为有向无环图（DAG）。

甚至可能将这种状态以 B- 或 B+ Tree 的形式保存在磁盘上，其包含所有相关通过哈希索引的单元（可能带有一些额外的数据，如子树高度或参考计数器）。 然而，这种天真想法的实现将导致一个智能合约的状态分散在本地磁盘文件和远端文件中，这是我们需要避免的。

现在我们将详细解释 TON 区块链的几乎所有对象如何表示为“单元袋”，从而证明了这种方法的普遍性。

### 2.5.6 区块就是“单元袋”

区块本身可以用代数类型描述，并存储为“单元袋”。 然后，可以简单地通过以任意顺序连接表示“单元袋”中的每个单元的字节串来获得区块的朴素二进制表示。 例如，通过在块的开头提供所有单元的偏移列表，并且尽可能用该列表中的 32 位索引替换成其它单元的引用。 然而，人们应该想象一个区块本质上是一个“单元袋”，所有其它技术细节都只是次要的。

### 2.5.7 将对象作为“单元袋”更新

想象一下，我们有一个表示为“单元袋”的某个旧版本对象，现在我们想要一个代表相同对象的新版本。 方法可能只是将新状态表示为具有其自身根的另一个“单元袋”，并从中移除旧版本中出现的所有单元。则剩下的“单元袋”本质上是对象的更新。再将两个单元联合起来，然后删除旧的根（如果引用计数器变为零，则减少其引用计数器并取消分配单元），那么拥有此对象的旧版本和更新版的每个人都可以计算出新版本。

### 2.5.8 更新帐户状态

特别是，可以使用2.5.7中描述的思想来表示对帐户状态或分片链的全局状态或任何散列映射更新。 这意味着当我们收到一个新的区块（这是一个“单元袋”）时，我们不仅仅是单独处理这个“单元袋”，而是将它首先与代表前一状态的“单元袋”结合起来。在这个意义上，每个区块都可以“包含”区块链的整个状态。

### 2.5.9 更新区块

回想一下，区块本身就是一个“单元袋”，因此，如果需要编辑一个块，就可以类似地将“块更新”定义为“单元袋”，“单元袋”这是该块的先前版本，以便进行如上所描述的处理。这大致是 2.1.17 中讨论的“垂直块”背后的想法。

### 2.5.10 Merkle 证明作为“单元袋”

请注意，（广义）Merkle 证明 - 例如，一个断言 x[i] = y 从已知值 Hash(x) = h（参见2.3.10和2.3.15）开始 - 也可以表示为一袋“单元”。 也就是说，只需要提供一个单元的子集，该子集对应于从 x: Hashmap(n, X) 的根到其所需叶子的路径，其索引为 i: 2n，值为 y: X。如果这些单元的子节点的引用不在这个路径中，将由单元哈希的方式保留为“未解决”。 同时 Merkle 证明也可以通过在“单元袋”中位于从根部的两条路径的并集上的单元来提供，例如 x[i] = y 和 x[i'] = y'， x 对应于索引 i 和 i' 的叶子。

### 2.5.11 Merkle 证明作为来自全节点的查询响应

实质上，具有分片链（或帐户链）状态的完整副本的全节点可以在轻节点（例如，运行 TON 区块链客户端的轻型版本的网络节点）请求时提供 Merkle 证明，从而允许查询者在没有外部帮助的情况下，仅使用此 Merkle 证明中提供的单元执行一些简单的查询。轻节点可以将序列化的查询发送到全节点，并通过 Merkle 证明接收正确响应。 这个 Merkle 证明只包含一个只属于那些分片链状态单元的“单元袋”。 这种方法尤其适用于执行智能合约的“GET 查询”（参见4.3.12）。

### 2.5.12 使用 Merkle 有效性证明进行扩充更新或状态更新

回想一下（参见2.5.7）我们可以通过“更新”来描述对象状态从旧值 x: X 到新值 x': X 的变化。步骤是假定接收者具有旧值 x 及其所有单元的副本，用包含位于表示新值 x' 的子树中的那些单元，但不包含表示旧值 x 的子树中的单元的“单元袋” ，再将两个单元联合起来，然后删除旧的根。

但是，如果接收者没有 x 的完整副本，只知道它的（Merkle）散列 h = Hash(x)，它将无法检查更新的有效性。 但我们希望得到“可验证的”更新，并通过 Merkle 证明旧状态中所有被引用的单元存在，然后任何只知道 h = Hash(x) 的人都能够检查更新的有效性并能够自己计算新的 h' = Hash(x')。

因为我们的 Merkle 证明本身就是“单元袋”（参见2.5.10），所以可以通过“单元袋”构造为扩充更新，这个“单元袋”包含 x 的旧根，以及通过 x 连接的一些子节点，和新的 x' 的根节点和不属于 x 的所有子节点。

### 2.5.13 分片区块中的帐户状态更新

特别是，应该扩充如 2.5.12 所述分片区块中的帐户状态。 否则，有人可能会提交一个包含无效状态（引用了旧状态的缺失单元）更新的块; 如何证明这种无效性成为了一个挑战。

现在，如果块中包含的所有状态更新都得到了扩充，则很容易检查它们的有效性，并且它们的无效性也很容易违反（广义）Merkle 哈希的递归定义。

### 2.5.14 “一切都是单元袋”哲学

上诉表明，我们需要在 TON 区块链或网络中存储或传输的所有内容都可以表示为“一袋单元”。 这是 TON 区块链设计理念的重要组成部分。 一旦理解了“单元袋”并定义了“单元袋”的一些“低级”序列化，就可以在高层次的抽象上简单地定义所有内容（块格式，分片和帐户状态，数据类型等）。

“一切都是一袋单元”的统一理念大大简化了看似无关的服务的实现; 如 5.1.9 中涉及的支付通道。

### 2.5.15 TON Blockchain 的区块头

通常，区块链中的块以块头开始，其包含前一个块的哈希，其创建时间，块中包含的所有交易的树的 Merkle 散列，等等。然后将该头的哈希定义为块的哈希。因为块头最终取决于块中包含的所有数据，所以不能在不改变其散列的情况下改变块。

在 TON 区块链块使用的“单元袋”方法中，没有指定的块头。相反，块哈希被定义为块的根单元的（Merkle）哈希。 因此，块的顶部（根）单元可能被认为是该块的“头”。

但是，根单元可能不包含（通常区块头中）预期的所有数据。 实质上，*Block* 类型中定义的一些字段才会在头中包含。 通常，包括根在内的这些字段将被包含在几个单元中，它们共同构成“Merkle 证明”的单元。有人可能会在任何其他单元之前就包含这些字段，然后，只需要下载块的前几个字节，以获得所有“头单元”。

## 2.6 创建和验证新块

TON 区块链最终由分片块和主链块组成。 必须通过网络创建、验证这些块并将其传播给所有相关方，以使系统平稳正确地运行。

### 2.6.1 验证人

新块由指定的特殊节点（称为人）创建和验证。 基本上，任何节点都可以成为验证人节点，只要它能够将足够大的权益（TON 代币，即 Grams; 参见附录A）存入主链。 验证人将从新生成的块、存储和手续费中获得工作“奖励”，即反映了整个社区对它的“感激”。 该收入按比例分配给所有参与的验证人，以保持 TON 区块链的正常工作。

然而，验证人是一项高度负责任的工作。如果验证人签署了无效区块，则可以通过损失部分或全部股权来处罚，并暂时或永久地从验证人中踢除。如果验证人不参与创建块，则它不会收到与该块相关的奖励份额。 如果验证者人长期放弃创建新块，它可能会丢失部分股份，并被暂停或永久排除在验证人之外。

所有这一切都意味着验证人不会“无所事事”地获得金钱。 实际上，它必须跟踪所有或一些分片链的状态（每个验证人负责验证和创建分片链的某个子集中的新块），执行这些分片链中智能合约的计算，接收有关其它分片链的更新等。此活动需要相当大的磁盘空间，计算能力和网络带宽。

### 2.6.2 验证人而不是矿工

回想一下，TON 区块链使用的是 Proof-of-Stake 方法，而不是当前版的本比特币和以太坊以及大多数其它加密货币采用的 Proof-of-Work 证明方法。 这意味着人们不能“挖掘”新的块获得一些新的代币。 相反，必须成为验证者并花费个人的计算资源来存储和处理 TON 区块链请求和数据。 简而言之，一个人必须是验证者才能开采新的代币。 在这方面，验证人就是新的矿工。

然而，除了作为验证者之外，还有其他一些获得收入的方法。

### 2.6.3 提名者者和“矿池”

要成为验证人，通常需要购买和安装多个高性能服务器并为他们提供良好的 Internet 连接。 所以这并不像目前开发比特币所需的 ASIC 设备那么昂贵。 然而，几乎不可能在家用电脑上挖掘出新的 TON 代币，更不用说智能手机了。

在比特币，以太坊和其他工作证明的加密货币挖掘社区中，有一个矿池的概念。矿池中有许多节点，但不具有足以自行挖掘新块的计算能力，矿池中的节点结合其力挖掘新块，并在之后共享奖励。

利益证明世界中的相应概念是提名者的概念。 从本质上讲，这是一个节点借钱来帮助验证人增加其股份; 验证人然后将其奖励的相应份额（或之前商定的一部分 - 比如50％）分配给提名者。

通过这种方式，提名者也可以参与“采矿”并为此目的存入与其意愿成比例的金额而获取一些奖励。 它仅获得验证人奖励的相应份额的一小部分，因为它仅提供“资本”，而不需要购买计算力，存储和网络带宽。

但是，如果验证人因无效行为而失去其股份，则提名人也会失去其股份。 从这个意义上说，提名者分担风险。 它必须明智地选择其指定的验证人，否则可能会赔钱。 从这个意义上说，提名者做出加权决定，并用他们的资金对某些验证人进行“投票”。

另一方面，这个提名或借出系统允许人们能够成为验证者，而无需先投入大量 Grams 资金（TON币）。 换句话说，它可以防止那些使用大量的 Grams 供应的人垄断验证人。

### 2.6.4 渔夫 (Fishermen): 通过指出别人的错误来获取回报

获得一些奖励另一种方法是成为一名渔夫 (Fishermen)。 基本上，任何节点都可以通过在主链中存入少量存款而成为渔夫。 然后它可以使用特殊的主链交易来发布由验证人先前签名和发布的一些（通常是分片链）块的无效（Merkle）证明。 如果其他验证人同意此无效证明，则违规验证人将受到处罚（丢失部分股份），并且渔夫将获得一些奖励（来自从违规验证人处没收的一小部分代币）。 之后，必须按照 2.1.17 中的描述更正无效（分片链）块。 纠正无效的主链块可能涉及在先前提交的主链块之上创建“垂直”块（参见2.1.17），因而没有必要创建主链的分叉。

通常，渔夫是一些分片链的完整节点，并通过运行一些智能合约代码来消耗计算资源。虽然渔夫不需要具有作为验证人的计算能力，但我们认为渔夫是处理新区块的潜在验证者的自然候选人，但尚未被选为验证者（ 例如，由于未能存放足够大的权益）。

### 2.6.5 整理人: 通过向验证者建议新块来获取回报

另一种获得一些奖励的方法是成为一名整理人。它向验证人准备并建议新的候选分片块，补充（整理）从该分片链和其他（通常是相邻的）分片链的状态和数据，以及合适的 Merkle 证明（例如，当某些消息需要从相邻的分片链转发时）。然后验证人可以轻松地检查建议的候选块的有效性，而无需下载此或其它分片链的完整状态。

因为验证人需要提交新的（整理的）候选区块以获得一些奖励，所以将一部分奖励支付给提供合适候选区块的整理人是有意义的。 通过这种方式，验证人可以通过将其外包给整理者来摆脱观察相邻碎片链状态的必要性。

但是，我们希望在系统的初始部署阶段不会有单独的指定整理人，因为所有验证人都可以自己充当整理人。

### 2.6.6 整理人或验证人: 通过收集用户交易获取回报

用户可以向一些整理人或验证人支付少量代币打开微支付通道，从而在分片链中包含他们的交易。

### 2.6.7 全局验证人选举

每个月选出一组“全局”验证人（实际上，每2^19个主链块）。 通常这是提前1一个月就已经普遍知晓的。

为了成为验证人，节点必须将一些TON代币（Grams）转移到主链中，然后将它们作为权益 s 发送给特殊的智能合约。 与权益一起发送的另一个参数是 *l ≥ 1*，该节点愿意接受的最大验证负载。 l 上还有一个全局上界（另一个可配置参数） *L*，等于10。

然后，通过这个智能合约选择全局验证人，仅仅选择最大权益的 T 位候选人并公布他们的身份。 最初，验证人的总数是 T = 100; 我们预计随着负载的增加它会增长到 1000，它是一个可配置的参数（参见2.1.21）。

每个验证人的实际利益计算如下: 如果最高 T 提议的权益是 s<sub>1</sub> ≥ s<sub>2</sub> ≥···≥ s<sub>T</sub>，则第 i 个验证人的实际权益设置为 s'<sub>i</sub> := min（s<sub>i</sub>, l<sub>i</sub> · s<sub>T</sub>）。 这样，s'<sub>i</sub> / s'<sub>T</sub> ≤ l<sub>i</sub>，因此第 i 个验证人的负载不超过最弱验证人负载的 l ≤ L 倍（因为负载最终与权益成比例）。

然后当选的验证人可以撤回其未使用的部分，即 s<sub>i</sub> - s'<sub>i</sub>。 为竞选上的的候选验证人可以撤回他们所有的股权。

每个验证人都要公开其公共签名密钥，这不一定等同于股份帐户的公钥。

直到验证人任职期结束，验证人的股份会被一直冻结，并且如果出现新的争议（即，发现这些验证人之一签署了无效区块），则会延长一个月。 在此之后，将返还股权，以及验证人的”挖矿“所得和在此期间处理的交易费用。

### 2.6.8 验证人“任务组”选举

整个全局验证人集合（其中每个验证人被认为具有等于其股权的多重性 - 否则验证人可能倾向于假设几个身份并将其中的利益分开）仅用于验证新的主链块。 分片链块仅通过特殊选择的验证人子集进行验证，这些验证人子集取自 2.6.7 中所述选择的全局证人集。

为每个分片定义的这些验证人“子集”或“任务组”每小时轮换一次（实际上，每 2^10 个主链块），并且它们是提前一小时知道的，这样每个验证人都知道哪些分片需要验证，以为此做好准备（例如，通过下载丢失的分片链数据）。

用于为每个分片 (w, s) 选择验证人任务组的算法是确定性伪随机的。 它使用验证人嵌入的伪随机数到每个主链块（由使用阈值签名的共识生成）来创建随机种子，然后每个验证器计算 *Hash(code(w). code(s).validator_id.rand_seed)*。 然后验证器按此散列值进行排序，并选择前几个验证器，以便至少具有验证人总股权的 *20/T*，并且至少包含5个验证人。

这种选择可以通过特殊的智能合约来完成。 在这种情况下，选择算法很容易升级，而不需要 2.1.21 中提到的投票机制的硬分叉。 到目前为止提到的所有其他“常数”（例如 2^19, 2^10, T, 20 和 5）也是可配置参数。

