# 3. TON 网络

任何区块链项目不仅需要区块格式和区块链验证规则和规范，还需要用于传播新块，发送和收集交易等的网络协议。换句话说，每个区块链项目都必须建立专门的 P2P 网络。这个网络必须是点对点的，因为区块链项目通常需要去中心化，因此不能依赖集中的服务器集群，以及使用传统的客户端 - 服务器架构，例如传统的在线银行应用。 即使轻客户端（例如，轻型加密钱包、智能手机应用程序）必须以类似客户端 - 服务器的方式连接到全节点，但实际上它可以自由连接到任何一个全节点。

虽然可以很容易地满足单链项目（如 Bitcoin 或 Ethereum）的网络需求（只需要构建一个“随机”对等覆盖网络，并通过合适的协议传播所有新块和候选交易），但多链项目，如 TON 区块链的要求更高（例如，必须能够支持只订阅一些分片的更新，而不是所有的分片）。因此，TON 项目的网络部分值得单独讨论。

另一方面，一旦支持 TON 区块链所需的更复杂的网络协议到位，就会发现它们可以很容易地用于不一定与 TON 区块链直接相关的项目，从而在 TON 生态系统中创建新服务提供更多的可能性和灵活性。

## 3.1 抽象数据报网络层

构建 TON 网络协议的基础是 TON 抽象数据报网络层 (Abstract Datagram Network Layer)。 它使所有节点能够由 256 位的“抽象网络地址ID”表示，并仅使用这些 256 位网络地址进行通信以识别发送方和收件人。特别是，用户不再关心 IPv4 或 IPv6 地址，UDP 端口号等，它们已被抽象网络层所隐藏。

### 3.1.1 抽象网络地址

抽象网络地址或抽象地址（或简称地址）是一个 256 位整数，实质上大致等于 256 位 ECC 公钥。节点可以任意生成公钥，从而创建不同的网络标识。 但是，必须知道相应的私钥才能接收（和解密）该地址的消息。

实际上，地址本身并不是公钥; 相反，它是序列化 TL-Object（参见2.2.5）的 256 位哈希值（Hash = SHA256），其可以根据构造函数中（前四个字节）描述的几种类型的公钥和地址进行序列化。在最简单的情况下，这个序列化的 TL-Object 只包含一个 4 字节的魔数和一个 256 位的椭圆曲线加密（ECC）公钥; 在这种情况下，地址将等于这个 36 字节的哈希。但也可以使用 2048 位 RSA 或任何其他公钥加密方案。

当一个节点知道了另一个节点的抽象地址时，它还必须接收其 “preimage”（即序列化的 TL-Object，其哈希等于该抽象地址），否则它将无法加密并将数据发送到该地址。

### 3.1.2 用 UDP 实现的低级网络

从几乎所有 TON 网络组件的角度来看，唯一存在的是一个能够将数据报从一个抽象地址（不可靠地）发送到另一个抽象地址的网络（抽象数据网络层）。原则上，抽象数据网络层（ADNL）可以在不同的现有网络技术上实现。 但是，我们将在 IPv4 / IPv6 网络（例如 Internet 或 Intranet）中通过 UDP 实现它，如果UDP不可用，则使用可选的 TCP。

### 3.1.3 最简单的 ADNL over UDP

从发送者的抽象地址向任意其它抽象地址（具有已知的 preimage）发送数据报的最简单情况可以如下实现。

假设发送方以某种方式知道接收方抽象地址的 IP 和 UDP 端口，并且接收方和发送方都使用从 256 位 ECC 公钥派生的抽象地址。

在这种情况下，发送者只是通过其 ECC 签名（使用其私钥完成）及其源地址（或源地址的 preimage）来发送数据报。 数据使用接受方的公钥加密，并嵌入 UDP 数据报中发送到收件人的 IP 和端口。 由于 UDP 数据报的前 256 位包含收件人的抽象地址，因此收件人可以识别应使用哪个私钥来解密数据报的其余部分。 只有解密之后才会知道发件人的身份。

### 3.1.4 安全性较低的方式，发送方的地址为明文

有时，接收方和发送方的地址以明文形式保存在 UDP 数据报中，虽然安全性较低，但也足够了。使用 ECDH（Elliptic Curve Diffie-Hellman）将发送方的私钥和接收方的公钥组合在一起，生成一个稍后使用的 256 位的共享密钥，以及未加密的 256 位随机数用于计算 AES 密钥。 例如，可以通过将数据的散列添加到原始明文之前提供完整性。

这种方法的优点是，如果预计在两个地址之间交换多个数据报，则只需计算一次共享密钥，把密钥缓存起来，然后下一个数据报的加密或解密将不再需要重新计算密钥。

### 3.1.5 通道和通道 ID

在最简单的情况下，UDP 数据报的前 256 位将等于接收者地址。然而，通常它们也构成了通道标识符。 通道具有不同类型。其中一些是点对点的; 它们是由希望在未来交换大量数据的双方创建的，并通过运行经典或Elliptic Curve Diffie-Hellman 算法交换如 3.1.3 或 3.1.4 所述的数据包来生成共享密钥，或者只是由一方产生随机共享密钥并将其发送给另一方。

在此之后，将共享密钥结合一些附加数据（例如发送者和接收者的地址）派生出通道 ID。

### 3.1.6 通道作为隧道标识符

通常，“通道”或“通道标识符”仅处理接收者已知的入站 UDP 数据报。 如果通道是接收方的抽象地址，则按照3.1.3 或 3.1.4 的规定进行处理; 如果通道是 3.1.5 中讨论的已建立的点对点通道，则使用共享密钥解密数据，如 3.1.5 中所解释的。

特别地，通道标识符实际上可以用于选择“隧道” —— 当接收者简单地将所接收的消息转发给其他人，接收者实际上就充当了一个代理。一些加密或解密步骤（让人联想到“Onion 路由”甚至“[Garlic 路由](https://geti2p.net/en/docs/how/garlic-routing)”）可能会在此过程中完成，而另一些通道可能会用于重新加密的转发数据包（例如，一条 P2P 通道可能被用于转发数据给下一个接受者）。

通过这种方式，可以在 TON 抽象数据报网络层上添加一些对“隧道”和“代理”的支持 —— 与 TOR 或 I<sup>2</sup>P 项目相似 —— 而不会影响到 TON 抽象数据报网络层的功能以及更高级的 TON 网络协议，例如，TON Proxy 服务就是通过这样的方式实现的（参见 4.1.11）。

### 3.1.7 零通道和引导问题

通常，TON ADNL 节点具有一些“邻节点表”，其包含关于其它已知节点的信息，例如它们的抽象地址及其 preimage（即，公钥）、IP 和 UDP 端口。然后，它们通过已知节点获取信息扩展此表，并且有时会移除废弃的记录。

但是，当 TON ADNL 节点刚启动时，可能不知道任何其它节点。例如，如果轻客户端无法访问先前缓存的节点以及任何软件中硬编码的节点，就必须要求用户输入节点的 IP 地址或域名。

在这种情况下，节点将数据包发送到特殊的“零信道”。这不需要知道接收者的公钥（但数据包仍应包含发件人的 ID 和签名），因此数据包无需加密即可传输。 它通常仅用于获取接收者的身份（可能为此目的而创建一次性 ID），然后以更安全的方式开始通信。

一旦知道了至少一个节点，就很容易通过和其它节点通讯以获得更多条目填充“邻节点表”和“路由表”。

并非所有节点都需要处理发送到零通道的数据，但用于引导轻客户端的那些节点应该支持此功能。

### 3.1.8 ADNL 上类似 TCP 的流协议

ADNL 将基于 256 位抽象地址的不可靠数据报协议用于更复杂网络协议的基础。例如，可以使用 ADNL 作为 IP 的抽象替代来构建类似 TCP 的流协议。但是，TON 项目的大多数组件都不需要这样的流协议。

### 3.1.9 RLDP(Reliable Large Datagram Protocol)， ADNL 上的可靠大数据报协议

使用基于 ADNL 构建的可靠任意大小数据报协议（Reliable Large Datagram Protocol，简写为 RLDP）代替类似 TCP 的协议。 例如，可以使用这种可靠的数据报协议将 RPC 查询发送到远程主机并从它们接收回应（参见4.1.5）。

## 3.2 TON DHT: 类似 Kademlia 的分布式哈希表

TON 分布式哈希表（DHT）在 TON 项目中定位网络中的其他节点起着至关重要的作用。 例如，想要将交易提交到分片链可能需要找到该分片的验证人或整理人，或者至少某个可能将客户端的交易中继到整理人的节点。 这可以通过在 TON DHT 中查找特殊键来完成。 TON DH T的另一个重要应用是它可以用随机密钥或新节点的地址来快速填充新节点的邻节点表（参见3.1.7）。 如果节点对其入站数据报使用代理和隧道，则它在 TON DHT 中发布隧道 ID 及其入口点（例如，IP 和 UDP 端口）; 那么希望将数据报发送到该节点的所有其它节点将首先从 DHT 获得该联系信息。

TON DHT 是类似 Kademlia 分布式哈希表家族的成员。

### 3.2.1 TON DHT 的键

TON DHT 的键只是 256 位整数。 在大多数情况下，它们是 TL-序列化对象的 SHA256（参见2.2.5），该哈希值被命名为 preimage 或键描述符。 在某些情况下，TON 网络节点的抽象地址（参见3.1.1）也可以用作TON DHT 的键，因为它们也是 256 位的，并且也是 TL-序列化对象的哈希。 例如，如果节点不介意公布其 IP 地址，则任何知道其抽象地址的节点都可以通过简单地将该（抽象）地址作为 DHT 中的键来查找。

### 3.2.2 TON DHT 的值

分配给这些 256 位键的值基本上是有限长度的任意字符串。 字符串的解释由 preimage 的原始值决定; 查找该键的节点通常是知道其含义的。

### 3.2.3 DHT 的节点和半永久性网络 ID

TON DHT 的键值映射保存在 DHT 的节点上（基本上是 TON 网络的所有成员）。 为此，除了 3.1.1 中描述的任何数量的短暂永久抽象地址之外，TON 网络的任何节点（除了一些非常“轻”的节点）也至少具有一个“半永久地址”，其将节点标识为 TON DHT 的成员。这个半永久性 DHT 地址不应该经常更改，否则其它节点将无法找到它们正在寻找的键。 如果节点不想显示其“真实”标识，则它会生成一个单独的抽象地址，仅用于 DHT。但是，此抽象地址必须是公开的，因为它将与节点的 IP 地址和端口关联。

### 3.2.4 Kademlia 距离

我们有 256 位键和 256 位（半永久）节点地址。 现在我们引入所谓的 *XOR 距离* 或 *Kademlia 距离* *d<sub>K</sub>*，由下式给出:

> (式25) d<sub>K</sub>(x, y) := (x ⊕ y) 

这里 *x⊕y* 表示相同长度的两个比特序列的按位异或（XOR）。

Kademlia 距离在所有 256 位序列的集合 2^256 上引入度量标准。 特别地，当且仅当 x = y，d<sub>K</sub>(x, y) = d<sub>K</sub>(y, x)，且 d<sub>K</sub>(x, z) ≤ d<sub>K</sub>(x, y) + d<sub>K</sub>(y, z)，我们有 d<sub>K</sub>(x, y) = 0。另一个重要特性是在距 *x* 的任何给定距离只有唯一一个点： d<sub>K</sub>(x, y) = d<sub>K</sub>(x, y')，即 y = y'。

### 3.2.5 Kademlia-like DHT 以及 TON DHT

我们说用 256 位键或 256 位节点地址的 DHT 是 Kademlia-like DHT，它用于将键 K 映射到最近 Kademlia 距离的 s 个节点上。

这里 s 是一个参数，比如 s = 7，以提高 DHT 的可靠性（如果我们只将键保存在最接近 K 的那一个节点上，如果保存那个键的节点离线的话，值就会丢失 ）。

根据这个定义，TON DHT 是 Kademlia-like DHT。 它是通过 3.1 中描述的 ADNL 协议实现的。

### 3.2.6 Kademlia 路由表

