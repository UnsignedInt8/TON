# 5. TON Payments

我们将在本文中简要讨论的 TON 项目的最后一个组成部分 —— TON Payments，这是（微）支付通道和“闪电网络”组成的价值转移平台。 它将实现“即时”支付，而无需将所有交易提交到区块链中，也无需支付相关的交易费用（例如，消耗的燃料费），并且不用等待五秒钟确认新区块包含有关交易。

由于这种即时支付的总体开销很小，所以人们将它们用于小额支付。 例如，TON 文件存储服务可能会要求每 128K 下载数据支付小额费用，又或者使用付费 TON Proxy 可能需要为每中继128 KiB 流量提供一些小额微支付。

虽然 TON Payments 可能会晚于 TON 项目的核心组件发布，但在一开始就需要考虑一些因素。 例如，用于执行 TON 区块链智能合约代码的 TON 虚拟机（TON VM; 参见 2.1.20）必须支持 Merkle 证明的一些特殊操作。 如果原始设计中没有此类支持，则在稍后添加它可能会成为问题（参见 2.8.16）。 但是，我们将看到 TON VM 原生支持“智能”支付通道（参见 5.1.9）。

### 5.1 支付通道

我们首先讨论点对点支付通道，以及如何在 TON 区块链中实现它们。

### 5.1.1 支付通道的构思

假设 A 和 B 两方都知道他们将来需要相互支付很多款项。他们不是将每笔付款作为区块链中的交易，而是创建一个共享的“资金池”（或者是一个只有两个帐户的小型私人银行），并为其提供一些资金：A 存放 a 个币，B 存放 b 个币。 这是通过在区块链中创建一个特殊的智能合约并将代币汇给它来实现的。

在创建“资金池”之前，双方都要同意某个协议。 他们将跟踪"资金池"的*状态* - 即共享池中的余额。 最初，状态是 *(a, b)*，意思是 a 个币属于A，b 个币属于 B。然后，如果 A 想要向 B 支付代币，他们可以简单地同意新状态是 *(a', b') = (a - d, b + d)*。

之后，如果 B 想要向 A 支付代币，则状态将变为 *(a'', b'') = (a' + d', b' - d')*，依此类推。

所有池内的这些余额更新完全都是链下的。 当双方决定从池中取出自己的资金时，他们会根据资金池的最终状态进行提取。 这实际上是通过向智能合约发送特殊消息来实现的，消息中包含商定的最终状态 (a\*, b\*) 以及 A 和 B 的签名。然后智能合约向 A 发送 a\* 个币，B 发送 b\* 个币，之后合约自动销毁。

此智能合约以及 A 和 B 用于更新池状态的网络协议是 *A 和 B 之间的简单支付通道*。根据 4.1.2 中描述的分类，它是一种混合服务：它的部分状态存在于区块链（智能合约）中，但其它大多数状态更新都是在链下（通过网络协议）执行的。 如果一切顺利，双方将能够按照自己的意愿执行尽可能多的交易（唯一的限制是通道的“容量”不会超支 - 即，他们在支付通道中的余额都是非负的）。所以，在链上就只需要两个交易：一个用于打开（创建）支付通道（智能合约），另一个用于关闭（销毁）它。

### 5.1.2 无信任的支付通道

前面的例子有点不切实际，因为它假设双方都绝不会欺骗对方以获得某些利益。 想象一下，A 如果不愿意在 *(a', b') 且 a' \< a* 的情况下对最终状态签名，这将使 B 陷入困境。

为了防止这种情况，人们通常会尝试开发无信任的支付通道协议，这些协议不要求各方相互信任，并惩罚任何试图作弊的一方。

这通常借助签名来实现。支付通道智能合约知道 A 和 B 的公钥，并且如果需要，它可以检查他们的签名。支付通道协议要求各方签署中间状态并将签名发送给彼此。 然后，如果其中一方作弊（例如，假装支付通道的某些状态从未存在），就可以通过在该状态上显示其签名来证明其不当行为。支付通道智能合约充当“链上仲裁者”，能够处理双方关于彼此的投诉，并通过没收所有资金来惩罚作弊方，然后将没收的资金奖励给另一方。

### 5.1.3 简单的双向同步无信任支付通道

考虑以下更实际的例子：由三元组 (δ<sub>i</sub>, i, o<sub>i</sub>)来描述支付通道的状态，其中 i 是状态的序列号（原始值是零，然后逐步加 1），δ<sub>i</sub> 是通道状态的改变值（即，A 和 B 分别 a + δ<sub>i</sub> 和 b - δ<sub>i</sub>），并且 o<sub>i</sub> 标示下一次允许改变状态（A 或 B）的一方。在切换到下个状态之前，都必须由 A 和 B 对本次状态进行签名。

现在，如果 A 想要通过支付通道将 d 个币转移给 B，并且当前状态是 S<sub>i</sub> = (δ<sub>i</sub>, i, o<sub>i</sub>)，其中 o<sub>i</sub> = A，则它只是创建了一个新状态 S<sub>i + 1</sub> = (δ<sub>i</sub> - d ，i + 1，o<sub>i + 1</sub>），并将其连同签名一起发送给 B。然后 B 确认 A 的签名后再将 B 对该状态的签名副本发送给 A。之后，双方都拥有新的签名副本，就可以转移资金了。

如果 A 想要在 o<sub>i</sub> = B 的状态 S<sub>i</sub> 中将代币转移给 B，则它首先要求 B 提交具有相同的 δ<sub>i</sub> + 1 = δ<sub>i</sub> 的后续状态 S<sub>i + 1</sub>，并且 o<sub>i</sub> + 1 = A，之后 A 才能够进行价值转移。

当双方同意关闭支付通道时，他们都对最终状态S<sub>k</sub>进行签名，并调用 *clean* 或 *双方终止方法* 来结算最终状态。

如果另一方不同意提供其最终签名，或者仅仅是它不予回应，则可以单方面关闭该通道。为此，希望这样做的一方将调用 *单方终止方法*，向智能合约发送其最终状态、最终签名以及另一方最新状态的签名。在此之后，智能合约不会立即对收到的最终状态采取行动。相反，它等待一段时间（例如，一天）以使另一方呈现其最终状态。 当另一方提交其最终状态并结果与已提交的版本兼容时，智能合约会计算“真实”的最终状态并相应地分配资金。 如果另一方未能将其最终状态呈现给智能合约，则根据所呈现的最终状态的唯一副本重新分配资金。

如果双方中的一方作弊 - 例如，签署两个不同的最终状态，或签署两个不同的下一个状态 S 和 S' ，或签署无效的新状态 S<sub>i + 1</sub> （例如，δ<sub>i + 1</sub> \< -a or \> b）- 然后另一方可以向智能合约提交证明这种不当行为。作弊的一方将立即完全失去其在支付通道中的资金而受到惩罚。

这种简单的支付通道协议是公平的，即无论双方是否合作，任何一方都可以随时获得应付款，并且如果它试图作弊，就可能会失去支付通道的所有资金。

### 5.1.4 同步支付通道作为一个简单的带有两个验证人的虚拟区块链

以上简单同步支付信道的示例可以如下改进。 想象一下，状态序列 S<sub>0</sub>, S<sub>1</sub>, ..., S<sub>n</sub> 实际上是非常简单的区块链的块序列。 该区块链的每个块基本上仅包含区块链的当前状态，并且可能引用了前一个区块（哈希）。A 和 B 双方都充当此区块链的验证人，因此每个区块必须收集两个签名。 区块链的状态 S<sub>i</sub> 定义了下一个区块的指定生产者 o<sub>i</sub>，因此 A 和 B 之间不用竞争生成下一个区块。允许生产者 A 创建将资金从 A 转移到 B 的块（即，δ<sub>i + 1</sub> ≤ δ<sub>i</sub>），并且 B 只能创建将资金从 B 转移到 A 的块。

如果两个验证人就区块链的最终区块（和最终状态）达成一致，则通过收集双方的特殊“最终”签名来最终确定，并将其与最终区块一起提交给通道智能合约进行处理和重新分配资金。

如果验证人签署了无效区块，或者创建了一个分支，或者签署了两个不同的最终区块，则可以通过向智能合约提供其不当行为的证据来惩罚它，该合约充当两个验证人的“链上仲裁器”。然后，违规方将失去支付通道中的所有资金，这类似于失去其股份的验证人。

### 5.1.5 异步支付通道作为具有两个工作链的虚拟区块链

5.1.3 中讨论的同步支付通道具有一定的缺点：在另一方确认交易之前，不能开始下一笔交易（支付通道内的汇款）。 这可以通过用两个交互的虚拟工作链（或者说是分片链）系统替换 5.1.4 中讨论的单个虚拟区块链来解决。

第一条工作链中仅包含 A 的交易，其块只能由 A 生成; 它的状态是 S<sub>i</sub> = (i, φ<sub>i</sub>, j, ψ<sub>j</sub>），其中 i 是块序列号（即到目前为止由 A 执行的交易或汇款的数量），φ<sub>i</sub> 是从 A 转移到 B 的总资金，j 是 A 知道的 B 区块链中最近有效区块的序列号，ψ<sub>j</sub> 是其 j 个交易中从 B 转移到 A 的金额。 S<sub>i</sub> 的有效性条件是，如果 i > 0， ψ<sub>j</sub> ≥0，且 -a ≤ ψ<sub>j</sub> - φ<sub>i</sub> ≤ b，则 φ<sub>i</sub> ≥ 0, φ<sub>i</sub> ≥ φ<sub>i-1</sub>。

类似地，第二条工作链仅包含 B 的交易，其块仅由 B 生成; 其状态为 T<sub>j</sub> = (j, ψ<sub>j</sub>, i, φ<sub>i</sub>），且具有相似的有效性条件。

现在，如果 A 想要将一些资金转移给 B，它只需在其工作链中创建一个新块，签名并发送给 B，而无需等待确认。

由 A 签署其区块链的最终状态和 B 签署其区块链的最终状态，以及将这两个最终状态呈现给支付通道智能合约的 *终止方法* 来结算通道的最终状态。 单边终止也是可以的，但在这种情况下，智能合约必须至少在某个宽限期内等待另一方提交其最终状态。

### 5.1.6 单向支付通道

如果只有 A 需要向 B 付款（例如，B 是服务提供商，A 是其客户），则可以创建单边支付通道。 从本质上讲，它只是 5.1.5 中描述的没有第二个工作链的工作链。相反，也可以说 5.1.5 中描述的异步支付通道由两个统一支付通道组成，或是由同一智能合约管理的“半通道”。

### 5.1.7 更复杂的支付通道; Promise/承诺

我们将在 5.2.4 中看到“闪电网络”，这是通过多个支付通道实现的即时汇款，但这也让实现的复杂程度变得更高。

特别是，我们希望能够实现“有条件汇款（Promise）”： A 同意向 B 发送 c 个币，但 B 只有在满足某个条件时才会获得资金，例如，如果 B 对于一个已知的 v 可以用 Hash(u) = v 表示，则可以获得资金。 否则，A 就在一段时间后收回资金。

这样的承诺可以通过智能合约轻松实现。 但是，我们希望“承诺”和其他类型的有条件汇款可以在链下支付通道中进行，因为它们可以大大简化“闪电网络”中存在的一系列资金转移（参见 5.2.4）。

5.1.4 和 5.1.5 中概述的“支付通道作为简单的区块链”在这里变得很方便。 现在我们考虑一个更复杂的虚拟区块链，其状态包含一系列未实现的“承诺”，以及锁定在此类承诺中的资金数量。 这个区块链（或异步情况下的两条工作链）必须通过它们的哈希显式引用前面的块。 然而，一般机制仍然相同。

### 5.1.8 复杂的支付通道智能合约面临的挑战

请注意，虽然复杂支付通道的最终状态仍然很小，而且最终“结算”也很简单（如果双方已就其应付金额达成一致，并且双方已签署协议），但单边终止方法和惩罚欺诈行为的方法仍然十分复杂。实际上，他们必须能够检查不正当的 Merkle 证明，以及检查支付通道区块链中更复杂的交易是否已经正确处理。

换句话说，支付通道智能合约必须能够使用 Merkle 证明检查其“哈希有效性”，并且必须包含支付通道（虚拟）的 ev_trans 和 ev_block（参见2.2.6）的函数实现。

### 5.1.9 TON VM 支持“智能”支付通道

用于运行 TON 区块链智能合约代码的 TON VM 可以执行“智能”或复杂支付通道所需的智能合约（参见 5.1.8）。

上述问题在“一切都是单元袋”​范式的基础上​（参见 2.5.14）变得非常方便。由于所有块（包括临时支付通道区块链中的块）都表示为单元袋（并由一些数据类型描述），并且这同样适用于消息和 Merkle 证明，因此可以轻松地将 Merkle 证明嵌入到支付通道智能合约的入站消息中，Merkle 证明也将被自动检查。然后，智能合约将使用该值，并评估该区块链的 ev_block 函数（参见2.2.6）以及这个块以前的状态。然后将最终状态与块中断言的状态进行比较，如果 Merkle 证明无效，则抛出"absent node"异常。

通过这种方式，使用 TON 区块链智能合约实现智能支付通道的验证代码将变得非常简单。 也可以说，TON 虚拟机具有检查其他简单区块链有效性的内置支持。唯一的限制因素是要合并到智能合约入站消息中的 Merkle 证明的大小。

### 5.1.10 智能支付通道内的简单支付通道

我们想讨论在现有支付通道内创建简单（同步或异步）支付通道的可能性。

虽然这看起来有点令人费解，但理解和实现并不比 5.1.7 中讨论的“Promise”困难得多。 基本上，A 是根据某些其它（虚拟）支付通道的最终状态向 B 支付 c 个币，而不是在出现问题时承诺向另一方支付 c 个币。 一般来说，这个其它支付通道甚至不需要在 A 和 B 之间; 它可能是 C 和 D 通道，分别将 c 和 d 个币投入其简单支付通道中。 （这种可能性在后面的 5.2.5 中被使用）

如果支付通道是不对称的，则需要提交两个承诺到两个工作链中：如果“内部”简单支付通道的最终结算是负，且 0 ≤ -δ ≤ c，A 将承诺向 B 支付 -δ 个币; 如果 δ 为正，则 B 必须承诺向 A 支付 δ 个币。 另一方面，如果支付通道是对称的，这可以通过将一个“创建简单支付通道”交易与参数 (c, d) 一起提交到单个支付通道中来完成（这将冻结属于 A 的 c 个币），然后由 B 提交特殊的“确认交易”（这将冻结 B 的 d 个币）。

我们希望内部支付通道非常简单（例如，5.1.3 中讨论的简单同步支付通道），以最小化 Merkle 证明大小。 在 5.1.7 中描述的意义上，外部支付通道就必须是“智能的”。

## 5.2 支付通道网络，即“闪电网络”

现在我们准备讨论 TON Payments 的“闪电网络”，它可以实现任意两个参与节点之间的即时汇款。

### 5.2.1 支付通道的限制

支付通道对于期望在他们之间进行大量交易的各方非常有用。 但是，如果只需要向特定收件人转账一次或两次，那么与她建立支付通道将是不切实际的。 除此之外，创建支付通道意味着需要冻结支付通道中的大量资金，并且无论如何都需要至少两个区块链交易。

### 5.2.2 支付通道网络，即“闪电网络”

支付通道网络通过支付通道链实现资金转移，就可以克服支付通道的限制。 如果 A 希望将资金转移给 E，她不需要与 E 建立支付通道。而是通过几个中间节点（例如，四个支付通道，从 A 到 B，从 B 到 C，从 C 到 D，从 D 到 E）建立 A 到 E 的链接就足够了。

### 5.2.3 支付通道网络概述

回想一下，支付通道网络，也称为“闪电网络”，由一组参与节点组成，其中一些节点已在它们之间建立了长期支付通道。 而且我们也看到了这些支付通道必须是 5.1.7 意义上的“智能”通道。 当参与节点 A 想要将资金转移到节点 E 时，她需要试图找到在支付通道网络内 A 到 E 的链接路径。 当找到这样的路径时，她才能沿着这条路径进行“连锁汇款”。

### 5.2.4 资金转移链

假设存在从 A 到 B，B 到 C，C 到 D，D 到 E 的支付通道链，A 就可以将 x 个币转移给 E，

一种简单的方法是沿着现有的支付通道将 x 个币转移给 B，并要求 B 进一步转发给 C。但是，为什么 B 不简单地把资金据为己有？ 因此，必须采用更严谨的方法，才能不要求所有相关方必须相互信任。

这可以如下实现。 A 生成一个大的随机数 u 并计算其哈希 v = Hash(u)。然后她承诺如果有一个数字 u 的哈希值是 v（参见 5.1.7），那么她将向 B 支付 x 个币。此时，v 是已知的，但 u 仍然保密。

之后，B 在其支付通道中创建了向 C 汇款的类似承诺。但他并不惧怕给出这样的承诺，因为他知道 A 也会给他这样类似的承诺。如果 C 提出了哈希问题的解来收取 B 承诺的 x 个币，那么 B 将立即提交这个解来从 A 那里收取 x 个币。

然后创建 C 到 D 和 D 到 E 的类似承诺。 当承诺全部到位时，A 将通过转移链向 E 转移资金。

在本文中省略了一些细节。 例如，这些承诺必须具有不同的到期时间，并且承诺的金额可能在链上也略有不同（B 可能只承诺 x - ε 个币给 C，其中 ε 是预先商定的手续费）。 我们暂时忽略这些细节，因为它们对于理解支付通道如何运作以及如何在 TON 中实现这些细节并不太重要。

### 5.2.5 支付通道链中的虚拟支付通道

现在假设 A 和 E 期望彼此进行很多交易。他们可能会在区块链中创建一个新的支付通道，但因有些资金会被锁定在这个支付通道中，所以这仍然非常昂贵。另一种选择是对每笔付款使用 5.2.4 中描述的连锁汇款。 但是，这将涉及大量网络活动以及在支付通道的虚拟区块链中创建大量交易。

另一种方法是在支付通道网络中创建链接 A 到 E 的链内虚拟支付通道。 为此，A 和 E 为他们的交易创建（虚拟）区块链，就像他们要在区块链中创建支付通道一样。 然而，他们不是在区块链中创建支付通道智能合约，而是要求所有中间支付通道将 A 到 B，B 到 C 等连接起来，再在其中创建简单的支付通道，绑定 A 到 E 的虚拟区块链 （参见5.1.10）。 换句话说，现在根据 A 和 E 之间的每个中间支付通道内的资金进行最终结算。

如果虚拟支付通道是单向的，那么这种承诺可以很容易地实现，因为最终的余额 δ 将是非正的，因此可以在中间支付通道内以 5.2.4 中描述的相同顺序创建简单的支付通道。 它们的到期时间也可以以相同的方式设置。

如果虚拟支付通道是双向的，情况会稍微复杂一些。 在这种情况下，应该根据最终结算将 δ 个币转移到两个分开的“半承诺”中，如 5.1.10 所述：向前转移 δ<sup>-</sup> = max(0, -δ) 个币，以及向后转移 δ<sup>+</sup> = max(0, δ) 个币。这些“半承诺”可以在中间支付通道中独立创建，一个半承诺链从 A 到 E，另一个链方向相反。

### 5.2.6 寻找闪电网络中的路径

到目前为止，有一点仍然未被讨论：A 和 E 将如何在支付网络中找到连接他们的路径？如果支付网络不是太大，则可以使用类似 OSPF 的协议：支付网络的所有节点创建一个重叠网络（参见 3.3.17），然后每个节点通过 Gossip 协议向其邻节点传播所有可用链路（即，支付通道）。最终，所有节点都将拥有支付网络中所有支付通道的完整列表，并且能够自己找到最短路径。一旦找到一条候选路径，就可以通过包含完整路径的特殊 ADNL 数据报进行探测，并要求每个中间节点确认这条支付通道的存在，并进一步转发该数据。之后，资金转移链即可被构建出来，并开始工作。

### 5.2.7 优化

可以在此处进行一些优化。 例如，只有闪电网络的传输节点需要参与 5.2.6 中讨论的类似 OSPF 的协议。所以，可以通过闪电网络连接的两个“叶子”节点将彼此告知对方他们所连接的传输节点的列表。 然后检查从一个列表到另一个列表中的传输节点的路径，如上面 5.2.6 中所述。

### 5.2.8 结论

我们已经概述了 TON 的区块链和网络技术如何实现 TON Payments。TON Payments是一个链下即时支付平台。 该平台对于驻留在 TON 生态系统中的服务非常有用，以便让他们可以在需要时轻松收到小额付款。

